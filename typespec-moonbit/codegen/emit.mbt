///|
/// 将 CodeModel 渲染为 MoonBit 输出文件列表。
pub fn emit(
  crate_ : @codemodel.Crate,
  options : @lib.EmitterOptions,
) -> Array[OutputFile] {
  let files = Array::new(capacity=3)
  files.push(
    OutputFile::new("moon.pkg.json", emit_moon_pkg_json(crate_, options)),
  )
  files.push(OutputFile::new("README.mbt.md", emit_readme(crate_)))
  files.push(OutputFile::new("generated.mbt", emit_source(crate_)))
  files
}

///|
fn emit_moon_pkg_json(
  crate_ : @codemodel.Crate,
  _options : @lib.EmitterOptions,
) -> String {
  let _ = crate_
  let content =
    #|{
    #|  "import": [
    #|    { "path": "moonbitlang/async/http", "alias": "http" }
    #|  ]
    #|}
  content
}

///|
fn emit_readme(crate_ : @codemodel.Crate) -> String {
  let buf = StringBuilder::new(size_hint=64)
  buf.write_string("# ")
  buf.write_string(crate_.name())
  buf.write_string("\n\n")
  buf.write_string("由 TypeSpec 生成的 MoonBit 代码。\n")
  buf.to_string()
}

///|
fn emit_source(crate_ : @codemodel.Crate) -> String {
  let buf = StringBuilder::new(size_hint=256)
  buf.write_string("///|\n")
  buf.write_string("// Auto-generated by typespec-moonbit.\n")
  buf.write_string("// This is a stub output for initial wiring.\n")
  let clients = crate_.clients()
  if clients.length() == 0 {
    buf.write_string("// No clients found in CodeModel.\n")
  } else {
    for client in clients {
      emit_client(buf, client)
    }
  }
  buf.to_string()
}

///|
fn emit_client(buf : StringBuilder, client : @codemodel.Client) -> Unit {
  let type_name = make_client_type_name(client.name())
  buf.write_string("///|\n")
  buf.write_string("/// ")
  buf.write_string(type_name)
  buf.write_string(" HTTP 客户端。\n")
  buf.write_string("pub struct ")
  buf.write_string(type_name)
  buf.write_string(" {\n")
  buf.write_string("  base_url : String\n")
  buf.write_string("}\n\n")
  buf.write_string("///|\n")
  buf.write_string("/// 创建 ")
  buf.write_string(type_name)
  buf.write_string("。\n")
  buf.write_string("pub fn ")
  buf.write_string(type_name)
  buf.write_string("::new(base_url : String) -> ")
  buf.write_string(type_name)
  buf.write_string(" {\n")
  buf.write_string("  { base_url, }\n")
  buf.write_string("}\n")
  for op in client.methods() {
    emit_method(buf, type_name, op)
  }
  buf.write_string("\n")
}

///|
fn emit_method(
  buf : StringBuilder,
  type_name : String,
  op : @codemodel.Method,
) -> Unit {
  let fn_name = make_method_name(op.http_method(), op.path(), op.name())
  let path = op.path()
  buf.write_string("///|\n")
  buf.write_string("/// 调用 ")
  buf.write_string(op.http_method())
  buf.write_string(" ")
  buf.write_string(path)
  buf.write_string("。\n")
  buf.write_string("pub async fn ")
  buf.write_string(type_name)
  buf.write_string("::")
  buf.write_string(fn_name)
  buf.write_string("(self : ")
  buf.write_string(type_name)
  buf.write_string(") -> @http.Response raise {\n")
  buf.write_string("  let client = @http.Client::new(self.base_url)\n")
  buf.write_string("  defer client.close()\n")
  buf.write_string("  client.")
  buf.write_string(op.http_method().to_lower())
  buf.write_string("(\"")
  buf.write_string(path)
  buf.write_string("\")\n")
  buf.write_string("}\n")
}

///|
fn make_client_type_name(raw : String) -> String {
  let cleaned = sanitize_identifier(raw)
  let base = if cleaned.length() == 0 { "CLIENT" } else { cleaned.to_upper() }
  if base.has_suffix("CLIENT") {
    base
  } else {
    base + "CLIENT"
  }
}

///|
fn make_method_name(
  http_method : String,
  path : String,
  raw_name : String,
) -> String {
  let prefix = sanitize_identifier(http_method.to_lower())
  let path_part = trim_leading_underscores(sanitize_identifier(path.to_lower()))
  let name_part = sanitize_identifier(raw_name.to_lower())
  let base = if path_part.length() > 0 {
    path_part
  } else if name_part.length() > 0 {
    name_part
  } else {
    "call"
  }
  prefix + "_" + base
}

///|
fn sanitize_identifier(raw : String) -> String {
  let out = raw
    .replace_all(old="-", new="_")
    .replace_all(old=" ", new="_")
    .replace_all(old=":", new="_")
    .replace_all(old=".", new="_")
    .replace_all(old="/", new="_")
    .replace_all(old="{", new="_")
    .replace_all(old="}", new="_")
    .replace_all(old="+", new="_")
    .replace_all(old="*", new="_")
    .replace_all(old="?", new="_")
    .replace_all(old="=", new="_")
    .replace_all(old="&", new="_")
    .replace_all(old=",", new="_")
  if out.length() == 0 {
    "_"
  } else {
    out
  }
}

///|
fn trim_leading_underscores(raw : String) -> String {
  let chars = raw.to_array()
  let mut start = 0
  for ch in chars {
    if ch != '_' {
      break
    }
    start += 1
  }
  if start == 0 {
    raw
  } else if start >= chars.length() {
    ""
  } else {
    let sb = StringBuilder::new(size_hint=chars.length() - start)
    for i in start..<chars.length() {
      sb.write_char(chars[i])
    }
    sb.to_string()
  }
}
