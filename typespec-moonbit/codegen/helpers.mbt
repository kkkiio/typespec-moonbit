///|
/// 文本处理辅助函数（占位接口）。
pub fn indent(text : String, spaces : Int) -> String {
  let pad = String::make(spaces, ' ')
  let lines = text.split("\n").to_array()
  let sb = StringBuilder::new(size_hint=text.length() + lines.length() * spaces)
  let mut first = true
  for line in lines {
    if !first {
      sb.write_char('\n')
    }
    first = false
    if line.length() != 0 {
      sb.write_string(pad)
      sb.write_string(line.to_string())
    }
  }
  sb.to_string()
}

///|

///|
pub fn to_pascal_case(s : String) -> String {
  let sb = StringBuilder::new()
  let mut next_upper = true
  for c in s.to_array() {
    if (c >= 'a' && c <= 'z') ||
      (c >= 'A' && c <= 'Z') ||
      (c >= '0' && c <= '9') {
      if next_upper {
        if c >= 'a' && c <= 'z' {
          sb.write_char((c.to_int() - 32).to_char().unwrap())
        } else {
          sb.write_char(c)
        }
        next_upper = false
      } else {
        sb.write_char(c)
      }
    } else {
      next_upper = true
    }
  }
  sb.to_string()
}

///|
pub fn to_snake_case(s : String) -> String {
  let sb = StringBuilder::new()
  let mut last_was_separator = true
  for c in s.to_array() {
    if (c >= 'a' && c <= 'z') ||
      (c >= 'A' && c <= 'Z') ||
      (c >= '0' && c <= '9') {
      if c >= 'A' && c <= 'Z' {
        if !last_was_separator {
          sb.write_char('_')
        }
        sb.write_char((c.to_int() + 32).to_char().unwrap())
        last_was_separator = false
      } else {
        sb.write_char(c)
        last_was_separator = false
      }
    } else if !last_was_separator {
      sb.write_char('_')
      last_was_separator = true
    }
  }
  sb.to_string().trim(char_set="_").to_string()
}

///|
pub fn sanitize_identifier(s : String) -> String {
  let sb = StringBuilder::new()
  let mut first = true
  for c in s.to_array() {
    if (c >= 'a' && c <= 'z') ||
      (c >= 'A' && c <= 'Z') ||
      (c >= '0' && c <= '9') ||
      c == '_' {
      if first && c >= '0' && c <= '9' {
        sb.write_char('_')
      }
      sb.write_char(c)
      first = false
    } else {
      sb.write_char('_')
      first = false
    }
  }
  let res = sb.to_string()
  if res == "" {
    "_"
  } else {
    res
  }
}

///|
let uri_utils_tmpl =
  #|///|
  #|// Auto-generated by typespec-moonbit.
  #|// This is a stub output for initial wiring.
  #|
  #|///|
  #|// --- URI Template Helpers ---
  #|
  #|///|
  #|/// 将 path 字符串按 WHATWG URL Standard 的 path percent-encode set 做编码（类似 Rust `url::Url::set_path`）。
  #|///
  #|/// - 保留 `/` 作为路径分隔符（不会被编码为 `%2F`）
  #|/// - 对空格等不安全字符编码为 `%XX`
  #|/// - 如果已经存在合法的 `%XX`，不会 double-encode
  #|fn __tsmb_encode_path(path : String) -> String {
  #|  let bytes = @encoding/utf8.encode(path)
  #|  let out = StringBuilder::new(size_hint=bytes.length() * 3)
  #|  let mut i = 0
  #|  while i < bytes.length() {
  #|    let b = bytes[i]
  #|    // keep %XX
  #|    if b.to_int() == 0x25 &&
  #|      i + 2 < bytes.length() &&
  #|      __tsmb_is_hex_digit(bytes[i + 1]) &&
  #|      __tsmb_is_hex_digit(bytes[i + 2]) {
  #|      out.write_char('%')
  #|      out.write_char(bytes[i + 1].to_int().unsafe_to_char())
  #|      out.write_char(bytes[i + 2].to_int().unsafe_to_char())
  #|      i += 3
  #|      continue
  #|    }
  #|    // '/' as separator
  #|    if b.to_int() == 0x2F {
  #|      out.write_char('/')
  #|      i += 1
  #|      continue
  #|    }
  #|    // for special URLs, backslash is treated as separator
  #|    if b.to_int() == 0x5C {
  #|      out.write_char('/')
  #|      i += 1
  #|      continue
  #|    }
  #|    if __tsmb_should_encode_path_byte(b) {
  #|      out.write_char('%')
  #|      out.write_string(__tsmb_hex2(b))
  #|    } else {
  #|      out.write_char(b.to_int().unsafe_to_char())
  #|    }
  #|    i += 1
  #|  }
  #|  out.to_string()
  #|}
  #|
  #|///|
  #|/// 将 request target 编码为可用于 HTTP 请求的路径字符串。
  #|///
  #|/// - 仅对 `?` 或 `#` 之前的 path 部分做 `__tsmb_encode_path` 等价处理
  #|/// - `?query` 与 `#fragment` 部分保持原样（至少保证 `?` 不会被编码为 `%3F`）
  #|fn __tsmb_encode_request_target(target : String) -> String {
  #|  let bytes = @encoding/utf8.encode(target)
  #|  let out = StringBuilder::new(size_hint=bytes.length() * 3)
  #|  let mut i = 0
  #|  while i < bytes.length() {
  #|    let b = bytes[i]
  #|    // query/fragment separator: keep as-is, and keep the tail as-is
  #|    if b.to_int() == 0x3F || b.to_int() == 0x23 {
  #|      out.write_char(b.to_int().unsafe_to_char())
  #|      i += 1
  #|      while i < bytes.length() {
  #|        let bb = bytes[i]
  #|        // keep %XX
  #|        if bb.to_int() == 0x25 &&
  #|          i + 2 < bytes.length() &&
  #|          __tsmb_is_hex_digit(bytes[i + 1]) &&
  #|          __tsmb_is_hex_digit(bytes[i + 2]) {
  #|          out.write_char('%')
  #|          out.write_char(bytes[i + 1].to_int().unsafe_to_char())
  #|          out.write_char(bytes[i + 2].to_int().unsafe_to_char())
  #|          i += 3
  #|          continue
  #|        }
  #|        // keep ASCII bytes as-is, percent-encode others
  #|        let x = bb.to_int()
  #|        if x <= 0x1F || x == 0x7F || x >= 0x80 {
  #|          out.write_char('%')
  #|          out.write_string(__tsmb_hex2(bb))
  #|        } else {
  #|          out.write_char(x.unsafe_to_char())
  #|        }
  #|        i += 1
  #|      }
  #|      break
  #|    }
  #|    // keep %XX
  #|    if b.to_int() == 0x25 &&
  #|      i + 2 < bytes.length() &&
  #|      __tsmb_is_hex_digit(bytes[i + 1]) &&
  #|      __tsmb_is_hex_digit(bytes[i + 2]) {
  #|      out.write_char('%')
  #|      out.write_char(bytes[i + 1].to_int().unsafe_to_char())
  #|      out.write_char(bytes[i + 2].to_int().unsafe_to_char())
  #|      i += 3
  #|      continue
  #|    }
  #|    // '/' as separator
  #|    if b.to_int() == 0x2F {
  #|      out.write_char('/')
  #|      i += 1
  #|      continue
  #|    }
  #|    // for special URLs, backslash is treated as separator
  #|    if b.to_int() == 0x5C {
  #|      out.write_char('/')
  #|      i += 1
  #|      continue
  #|    }
  #|    if __tsmb_should_encode_path_byte(b) {
  #|      out.write_char('%')
  #|      out.write_string(__tsmb_hex2(b))
  #|    } else {
  #|      out.write_char(b.to_int().unsafe_to_char())
  #|    }
  #|    i += 1
  #|  }
  #|  out.to_string()
  #|}
  #|
  #|///|
  #|fn __tsmb_is_hex_digit(b : Byte) -> Bool {
  #|  match b.to_int() {
  #|    0x30..=0x39 => true // 0-9
  #|    0x41..=0x46 => true // A-F
  #|    0x61..=0x66 => true // a-f
  #|    _ => false
  #|  }
  #|}
  #|
  #|///|
  #|fn __tsmb_hex2(byte : Byte) -> String {
  #|  let mut s = byte.to_int().to_string(radix=16).to_upper()
  #|  if s.length() == 1 { s = "0" + s }
  #|  s
  #|}
  #|
  #|///|
  #|fn __tsmb_should_encode_path_byte(b : Byte) -> Bool {
  #|  // WHATWG URL Standard: path percent-encode set:
  #|  // controls + space + " < > ` + # ? { }
  #|  let x = b.to_int()
  #|  match x {
  #|    0x00..=0x1F => true
  #|    0x7F => true
  #|    0x20 => true // space
  #|    0x22 => true // "
  #|    0x3C => true // <
  #|    0x3E => true // >
  #|    0x60 => true // `
  #|    0x23 => true // #
  #|    0x3F => true // ?
  #|    0x7B => true // {
  #|    0x7D => true // }
  #|    0x25 => true // %
  #|    // for simplicity: encode non-ascii bytes
  #|    0x80..=0xFF => true
  #|    _ => false
  #|  }
  #|}
  #|
  #|///|
  #|fn __tsmb_join(xs : Array[String], sep : String) -> String {
  #|  let sb = StringBuilder::new(size_hint=32)
  #|  for i in 0..<xs.length() {
  #|    if i > 0 { sb.write_string(sep) }
  #|    sb.write_string(xs[i])
  #|  }
  #|  sb.to_string()
  #|}
  #|
  #|///|
  #|fn __tsmb_expand_string(op : String, name : String, _explode : Bool, value : String) -> String {
  #|  match op {
  #|    "?" => "?" + name + "=" + value
  #|    "&" => "&" + name + "=" + value
  #|    "/" => "/" + value
  #|    "." => "." + value
  #|    ";" => ";" + name + "=" + value
  #|    _ => value
  #|  }
  #|}
  #|
  #|///|
  #|fn __tsmb_expand_array(op : String, name : String, explode : Bool, value : Array[String]) -> String {
  #|  match op {
  #|    "?" =>
  #|      if explode {
  #|        let parts = Array::new(capacity=value.length())
  #|        for x in value { parts.push(name + "=" + x) }
  #|        "?" + __tsmb_join(parts, "&")
  #|      } else {
  #|        "?" + name + "=" + __tsmb_join(value, ",")
  #|      }
  #|    "&" =>
  #|      if explode {
  #|        let parts = Array::new(capacity=value.length())
  #|        for x in value { parts.push("&" + name + "=" + x) }
  #|        __tsmb_join(parts, "")
  #|      } else {
  #|        "&" + name + "=" + __tsmb_join(value, ",")
  #|      }
  #|    "/" => "/" + __tsmb_join(value, if explode { "/" } else { "," })
  #|    "." => "." + __tsmb_join(value, if explode { "." } else { "," })
  #|    ";" =>
  #|      if explode {
  #|        let parts = Array::new(capacity=value.length())
  #|        for x in value { parts.push(";" + name + "=" + x) }
  #|        __tsmb_join(parts, "")
  #|      } else {
  #|        ";" + name + "=" + __tsmb_join(value, ",")
  #|      }
  #|    _ => __tsmb_join(value, ",")
  #|  }
  #|}
  #|
  #|///|
  #|fn __tsmb_expand_record(op : String, name : String, explode : Bool, value : Map[String, Int]) -> String {
  #|  let pairs = value.to_array()
  #|  // Keep output stable by sorting by key.
  #|  pairs.sort_by_key(p => p.0)
  #|  match op {
  #|    "?" =>
  #|      if explode {
  #|        "?" + __tsmb_expand_record_inner(pairs, true, "&")
  #|      } else {
  #|        "?" + name + "=" + __tsmb_expand_record_inner(pairs, false, ",")
  #|      }
  #|    "&" =>
  #|      if explode {
  #|        let parts = Array::new()
  #|        for kv in pairs {
  #|          let k = kv.0
  #|          let v = kv.1
  #|          parts.push("&" + k + "=" + v.to_string())
  #|        }
  #|        __tsmb_join(parts, "")
  #|      } else {
  #|        "&" + name + "=" + __tsmb_expand_record_inner(pairs, false, ",")
  #|      }
  #|    "/" => "/" + __tsmb_expand_record_inner(pairs, explode, if explode { "/" } else { "," })
  #|    "." => "." + __tsmb_expand_record_inner(pairs, explode, if explode { "." } else { "," })
  #|    ";" =>
  #|      if explode {
  #|        let parts = Array::new()
  #|        for kv in pairs {
  #|          let k = kv.0
  #|          let v = kv.1
  #|          parts.push(";" + k + "=" + v.to_string())
  #|        }
  #|        __tsmb_join(parts, "")
  #|      } else {
  #|        ";" + name + "=" + __tsmb_expand_record_inner(pairs, false, ",")
  #|      }
  #|    _ => __tsmb_expand_record_inner(pairs, explode, ",")
  #|  }
  #|}
  #|
  #|///|
  #|fn __tsmb_expand_record_inner(pairs : Array[(String, Int)], explode : Bool, sep : String) -> String {
  #|  let parts = Array::new()
  #|  if explode {
  #|    for kv in pairs {
  #|      let k = kv.0
  #|      let v = kv.1
  #|      parts.push(k + "=" + v.to_string())
  #|    }
  #|    __tsmb_join(parts, sep)
  #|  } else {
  #|    for kv in pairs {
  #|      let k = kv.0
  #|      let v = kv.1
  #|      parts.push(k)
  #|      parts.push(v.to_string())
  #|    }
  #|    __tsmb_join(parts, ",")
  #|  }
  #|}
  #|
  #|///|
  #|// --- End Helpers ---
  #|
