/// Server 代码生成模块：生成基于 `moonbitlang/async/http` 的 server 包。

///|
/// 生成 server 包的文件列表。
pub fn emit_server_files(crate : @codemodel.Crate) -> Array[OutputFile] raise {
  let files = Array::new(capacity=3)
  files.push(OutputFile::new("moon.pkg.json", emit_server_moon_pkg_json()))
  files.push(OutputFile::new("README.mbt.md", emit_server_readme(crate)))
  files.push(OutputFile::new("router.mbt", emit_server_router(crate)))
  files
}

///|
fn emit_server_moon_pkg_json() -> String {
  (
    #|{
    #|  "import": [
    #|    "moonbitlang/async/http",
    #|    "moonbitlang/async/io"
    #|  ]
    #|}
  )
}

///|
fn emit_server_readme(crate : @codemodel.Crate) -> String {
  (
    $|# \{crate.name}
    $|
    $|Generated by typespec-moonbit.
    $|
    $|This MoonBit package can be imported by other packages to start a server.
  )
}

///|
let model_template : String =
  #|{{#models}}
  #|///|
  #|/// Model {{name}}
  #|pub(all) struct {{struct_name}} {
  #|{{#fields}}
  #|  {{name}} : {{type}}
  #|{{/fields}}
  #|} derive(Show, Default, ToJson, @json.FromJson(rename_fields="camelCase"))
  #|
  #|{{/models}}

///|
let handler_trait_template : String =
  #|{{#clients}}
  #|///|
  #|/// Traits for operation handlers
  #|pub(open) trait {{trait_name}} {
  #|  {{#methods}}async {{method_name}}(Self{{#params}}, {{name}} : {{type}}{{/params}}) -> Unit
  #|  {{/methods}}
  #|}
  #|{{/clients}}

///|
let router_template : String =
  #|pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit
  #|
  #|pub fn[{{#clients}}H{{client_index}} : {{trait_name}}{{^is_last}}, {{/is_last}}{{/clients}}] create_router({{#clients}}{{handler_var}} : H{{client_index}}{{^is_last}}, {{/is_last}}{{/clients}}) -> Router {
  #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) {
  #|    let path = strip_request_query(req.path)
  #|    if false { () }
  #|    {{#clients}}
  #|      {{#methods}}
  #|    else if req.meth == {{http_meth_token}} && match_path_template("{{{path_template}}}", path) {
  #|      {{#has_body}}let body_bytes = body_stream.read_all()
  #|      let body_str = body_bytes.text()
  #|      {{/has_body}}
  #|      {{^has_body}}ignore(body_stream)
  #|      {{/has_body}}
  #|      {{#params}}
  #|      {{#isBody}}{{#isString}}let {{var_name}} = body_str{{/isString}}{{^isString}}let {{var_name}} : {{type_str}} = try { @json.from_json(@json.parse(body_str)) } catch { _ => @json.from_json(null) }{{/isString}}{{/isBody}}
  #|      {{^isBody}}let {{var_name}} = ""{{/isBody}}
  #|      {{/params}}
  #|      {{{handler_var}}}.{{handler_method}}({{#params}}{{var_name}}{{^is_last}}, {{/is_last}}{{/params}})
  #|      conn.send_response(204, "No Content")
  #|    }
  #|      {{/methods}}
  #|    {{/clients}}
  #|    else {
  #|      conn.send_response(404, "NotFound")
  #|      conn.write("not found")
  #|    }
  #|  }
  #|}
  #|

///|
fn emit_create_router(crate : @codemodel.Crate) -> String raise {
  let clients = crate.clients
  let mut op_counter = 0
  let clients_ctx = Array::new()
  for i in 0..<clients.length() {
    let client = clients[i]
    let methods_arr = Array::new()
    for op in client.methods {
      op_counter += 1
      let meth = server_meth_ctor(op.http_method)
      let normalized_tmpl = normalize_uri_template(op.path)
      let tmpl = normalized_tmpl
        .replace_all(old="\\", new="\\\\")
        .replace_all(old="\"", new="\\\"")

      // detect body presence
      let has_body = for param in op.parameters {
        if param.location == "body" {
          break true
        }
      } else {
        false
      }
      let params_arr = Array::new()
      let param_count = op.parameters.length()
      for j in 0..<param_count {
        let param = op.parameters[j]
        let pname = sanitize_identifier(@case.snake_case(param.name))
        let var_name = "p_\{op_counter}_\{pname}"
        let type_str = type_ref_to_string(param.type_)
        params_arr.push(
          Json::object({
            "name": Json::string(@case.snake_case(param.name)),
            "var_name": Json::string(var_name),
            "location": Json::string(param.location),
            "type_str": Json::string(type_str),
            "isBody": Json::boolean(param.location == "body"),
            "isString": Json::boolean(type_str == "String"),
            "is_last": Json::boolean(j == param_count - 1),
          }),
        )
      }
      methods_arr.push(
        Json::object({
          "method_name": Json::string(@case.snake_case(op.name)),
          "handler_method": Json::string(@case.snake_case(op.name)),
          "http_meth_token": Json::string(meth),
          "path_template": Json::string(tmpl),
          "has_body": Json::boolean(has_body),
          "params": Json::array(params_arr),
        }),
      )
    }
    clients_ctx.push(
      Json::object({
        "handler_var": Json::string("h\{i}"),
        "trait_name": Json::string(
          @case.pascal_case(sanitize_identifier(client.name)) + "Handler",
        ),
        "client_index": Json::number(i.to_double()),
        "is_last": Json::boolean(i == clients.length() - 1),
        "methods": Json::array(methods_arr),
      }),
    )
  }
  @mustache.parse(
    router_template,
    Json::object({ "clients": Json::array(clients_ctx) }),
  )
}

///|
test "emit_server_router" {
  let router_code = emit_server_router({
    name: "test_crate",
    version: "0.1.0",
    clients: [
      @codemodel.Client::{
        name: "TestClient",
        methods: [
          @codemodel.Method::{
            name: "GetItem",
            http_method: "GET",
            path: "/items/{itemId}",
            status_code: 200,
            parameters: [
              @codemodel.Parameter::{
                name: "itemId",
                location: "path",
                type_: @codemodel.TypeRef::String,
              },
            ],
          },
          @codemodel.Method::{
            name: "CreateItem",
            http_method: "POST",
            path: "/items",
            status_code: 200,
            parameters: [
              @codemodel.Parameter::{
                name: "body",
                location: "body",
                type_: @codemodel.TypeRef::Model(@codemodel.Model::{
                  name: "Item",
                  fields: [
                    @codemodel.ModelField::{
                      name: "name",
                      type_: @codemodel.TypeRef::String,
                    },
                  ],
                }),
              },
            ],
          },
        ],
      },
    ],
  })
  inspect(
    router_code,
    content=(
      #|
      #|///|
      #|/// Model Item
      #|pub(all) struct Item {
      #|
      #|  name : String
      #|
      #|} derive(Show, Default, ToJson, @json.FromJson(rename_fields="camelCase"))
      #|
      #|
      #|///|
      #|/// Traits for operation handlers
      #|pub(open) trait TestClientHandler {
      #|  async get_item(Self, item_id : String) -> Unit
      #|  async create_item(Self, body : Item) -> Unit
      #|  
      #|}
      #|pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit
      #|
      #|pub fn[H0 : TestClientHandler] create_router(h0 : H0) -> Router {
      #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) {
      #|    let path = strip_request_query(req.path)
      #|    if false { () }
      #|    
      #|      
      #|    else if req.meth == @http.Get && match_path_template("/items/{itemId}", path) {
      #|      
      #|      ignore(body_stream)
      #|      
      #|      
      #|      
      #|      let p_1_item_id = ""
      #|      
      #|      h0.get_item(p_1_item_id)
      #|      conn.send_response(204, "No Content")
      #|    }
      #|      
      #|    else if req.meth == @http.Post && match_path_template("/items", path) {
      #|      let body_bytes = body_stream.read_all()
      #|      let body_str = body_bytes.text()
      #|      
      #|      
      #|      
      #|      let p_2_body : Item = try { @json.from_json(@json.parse(body_str)) } catch { _ => @json.from_json(null) }
      #|      
      #|      
      #|      h0.create_item(p_2_body)
      #|      conn.send_response(204, "No Content")
      #|    }
      #|      
      #|    
      #|    else {
      #|      conn.send_response(404, "NotFound")
      #|      conn.write("not found")
      #|    }
      #|  }
      #|}
      #|///|
      #|fn strip_request_query(path : String) -> String {
      #|  let parts = path.split("?").to_array()
      #|  if parts.length() == 0 { path } else { parts[0].to_string() }
      #|}
      #|///|
      #|fn match_path_template(template : String, path : String) -> Bool {
      #|  let t = template.trim(char_set="/")
      #|  let p = path.trim(char_set="/")
      #|  let t_segs = if t == "" { [] } else { t.split("/").to_array() }
      #|  let p_segs = if p == "" { [] } else { p.split("/").to_array() }
      #|  if t_segs.length() != p_segs.length() { return false }
      #|  for i in 0..<t_segs.length() {
      #|    let ts = t_segs[i].to_string()
      #|    let ps = p_segs[i].to_string()
      #|    if ts.length() >= 2 && ts.has_prefix("{") && ts.has_suffix("}") {
      #|      if ps == "" { return false }
      #|    } else if ts != ps { return false }
      #|  }
      #|  true
      #|}
      #|

    ),
  )
}

///|
fn emit_server_router(crate : @codemodel.Crate) -> String raise {
  let buf = StringBuilder::new(size_hint=8192)

  // 1. Collect Models
  let models = Map::new()
  for client in crate.clients {
    for op in client.methods {
      for param in op.parameters {
        collect_models(param.type_, models)
      }
    }
  }

  // 2. Generate Model Structs
  let model_list = models.to_array()
  model_list.sort_by_key(fn(m) { m.0 })
  let models_json = model_list.map(fn(item) {
    let m = item.1
    let fields = m.fields.map(fn(f) {
      Json::object({
        "name": Json::string(@case.snake_case(f.name)),
        "type": Json::string(type_ref_to_string(f.type_)),
      })
    })
    Json::object({
      "name": Json::string(m.name),
      "struct_name": Json::string(@case.pascal_case(m.name)),
      "fields": Json::array(fields),
    })
  })
  buf.write_string(
    @mustache.parse(
      model_template,
      Json::object({ "models": Json::array(models_json) }),
    ),
  )

  // 3. Generate Handler Traits

  let clients_json = crate.clients.map(fn(client) {
    let methods = client.methods.map(fn(op) {
      let params = op.parameters.map(fn(p) {
        Json::object({
          "name": Json::string(@case.snake_case(p.name)),
          "type": Json::string(type_ref_to_string(p.type_)),
        })
      })
      Json::object({
        "method_name": Json::string(@case.snake_case(op.name)),
        "params": Json::array(params),
      })
    })
    Json::object({
      "trait_name": Json::string(@case.pascal_case(client.name) + "Handler"),
      "methods": Json::array(methods),
    })
  })
  buf.write_string(
    @mustache.parse(
      handler_trait_template,
      Json::object({ "clients": Json::array(clients_json) }),
    ),
  )
  buf.write_string(emit_create_router(crate))
  buf.write_string(strip_request_query_code)
  buf.write_string(match_path_template_code)
  buf.to_string()
}

///|
let strip_request_query_code =
  #|///|
  #|fn strip_request_query(path : String) -> String {
  #|  let parts = path.split("?").to_array()
  #|  if parts.length() == 0 { path } else { parts[0].to_string() }
  #|}
  #|

///|
let match_path_template_code =
  #|///|
  #|fn match_path_template(template : String, path : String) -> Bool {
  #|  let t = template.trim(char_set="/")
  #|  let p = path.trim(char_set="/")
  #|  let t_segs = if t == "" { [] } else { t.split("/").to_array() }
  #|  let p_segs = if p == "" { [] } else { p.split("/").to_array() }
  #|  if t_segs.length() != p_segs.length() { return false }
  #|  for i in 0..<t_segs.length() {
  #|    let ts = t_segs[i].to_string()
  #|    let ps = p_segs[i].to_string()
  #|    if ts.length() >= 2 && ts.has_prefix("{") && ts.has_suffix("}") {
  #|      if ps == "" { return false }
  #|    } else if ts != ps { return false }
  #|  }
  #|  true
  #|}
  #|

///|
fn collect_models(
  type_ : @codemodel.TypeRef,
  models : Map[String, @codemodel.Model],
) -> Unit {
  match type_ {
    Model(m) =>
      if !models.contains(m.name) {
        models.set(m.name, m)
        for field in m.fields {
          collect_models(field.type_, models)
        }
      }
    Array(t) => collect_models(t, models)
    _ => ()
  }
}

///|
fn server_meth_ctor(http_method : String) -> String {
  match http_method.to_upper() {
    "GET" => "@http.Get"
    "HEAD" => "@http.Head"
    "POST" => "@http.Post"
    "PUT" => "@http.Put"
    "DELETE" => "@http.Delete"
    "PATCH" => "@http.Patch"
    "OPTIONS" => "@http.Options"
    "TRACE" => "@http.Trace"
    "CONNECT" => "@http.Connect"
    _ => "@http.Get"
  }
}

///|
fn normalize_uri_template(template : String) -> String {
  let p1 = template.split("{?").to_array()
  let s = if p1.length() == 0 { template } else { p1[0].to_string() }
  let p2 = s.split("?").to_array()
  if p2.length() == 0 {
    s
  } else {
    p2[0].to_string()
  }
}
