/// Server 代码生成模块：生成基于 `moonbitlang/async/http` 的 server 包。

///|
/// 生成 server 包的文件列表。
pub fn emit_server_files(crate : @codemodel.Crate) -> Array[OutputFile] raise {
  let files = Array::new(capacity=5)
  files.push(OutputFile::new("moon.pkg.json", emit_server_moon_pkg_json()))
  files.push(OutputFile::new("README.mbt.md", emit_server_readme(crate)))
  files.push(OutputFile::new("models.mbt", emit_server_models(crate)))
  files.push(OutputFile::new("router.mbt", emit_server_router(crate)))
  files.push(
    OutputFile::new("router_helpers.mbt", emit_server_router_helpers(crate)),
  )
  files
}

///|
fn emit_server_moon_pkg_json() -> String {
  (
    #|{
    #|  "import": [
    #|    "moonbitlang/async/http",
    #|    "moonbitlang/async/io",
    #|    "moonbitlang/core/json"
    #|  ]
    #|}
  )
}

///|
fn emit_server_readme(crate : @codemodel.Crate) -> String {
  (
    $|# \{crate.name}
    $|
    $|Generated by typespec-moonbit.
    $|
    $|This MoonBit package can be imported by other packages to start a server.
  )
}

///|
fn collect_models_from_crate(
  crate : @codemodel.Crate,
) -> Map[String, @codemodel.Model] {
  let models = Map::new()
  for client in crate.clients {
    for op in client.methods {
      for param in op.parameters {
        collect_models(param.type_, models)
      }
      match op.response_body {
        Some(t) => collect_models(t, models)
        None => ()
      }
    }
  }
  models
}

///|
let model_template : String =
  #|{{#models}}
  #|///|
  #|/// Model {{name}}
  #|pub(all) struct {{struct_name}} {
  #|{{#fields}}
  #|  {{name}} : {{type}}{{#optional}}?{{/optional}}
  #|{{/fields}}
  #|} derive(Show, Default, {{#derive_tojson}}ToJson, {{/derive_tojson}}@json.FromJson(rename_fields="camelCase"))
  #|
  #|{{^derive_tojson}}
  #|pub impl ToJson for {{struct_name}} with to_json(self : {{struct_name}}) -> Json {
  #|  let m : Map[String, Json] = Map::new()
  #|  {{#fields}}
  #|  {{^optional}}m.set("{{json_name}}", self.{{name}}.to_json())
  #|  {{/optional}}
  #|  {{#optional}}match self.{{name}} { Some(v) => m.set("{{json_name}}", v.to_json()) ; None => () }
  #|  {{/optional}}
  #|  {{/fields}}
  #|  Json::object(m)
  #|}
  #|{{/derive_tojson}}
  #|
  #|{{/models}}

///|
let handler_trait_template : String =
  #|{{#clients}}
  #|///|
  #|/// Traits for operation handlers
  #|pub(open) trait {{trait_name}} {
  #|  {{#methods}}async {{method_name}}(Self{{#params}}, {{name}} : {{type}}{{/params}}) -> {{return_type}}
  #|  {{/methods}}
  #|}
  #|{{/clients}}

///|
let nullable_support_code : String =
  #|///|
  #|/// Nullable helper used for `T | null`.
  #|pub(all) struct Nullable[T](T?) derive(Show, Default, Eq, Compare)
  #|
  #|///|
  #|pub impl[T : ToJson] ToJson for Nullable[T] with to_json(self : Nullable[T]) -> Json {
  #|  match self.0 {
  #|    Some(v) => v.to_json()
  #|    None => Json::null()
  #|  }
  #|}
  #|
  #|///|
  #|pub impl[T : @json.FromJson] @json.FromJson for Nullable[T] with from_json(
  #|  j : Json,
  #|  path : @json.JsonPath,
  #|) -> Nullable[T] raise @json.JsonDecodeError {
  #|  match j {
  #|    Null => Nullable(None)
  #|    _ => Nullable(Some(@json.from_json(j, path~)))
  #|  }
  #|}
  #|

///|
fn emit_server_models(crate : @codemodel.Crate) -> String raise {
  let buf = StringBuilder::new(size_hint=8192)

  // 1. Collect Models
  let models = collect_models_from_crate(crate)

  // 2. Nullable helper (for `T | null`)
  buf.write_string(nullable_support_code)

  // 3. Generate Model Structs
  let model_list = models.to_array()
  model_list.sort_by_key(fn(m) { m.0 })
  let models_json = model_list.map(fn(item) -> Json {
    let m = item.1
    let mut has_optional_fields = false
    for f in m.fields {
      if f.optional {
        has_optional_fields = true
      }
    }
    let fields = m.fields.map(fn(f) -> Json {
      {
        "name": @case.snake_case(f.name),
        "json_name": @case.camel_case(f.name),
        "type": type_ref_to_string(f.type_),
        "optional": f.optional,
      }
    })
    {
      "name": m.name,
      "struct_name": @case.pascal_case(m.name),
      "fields": fields,
      "derive_tojson": !has_optional_fields,
    }
  })
  buf.write_string(@mustache.parse(model_template, { "models": models_json }))
  buf.to_string()
}

///|
let router_template : String =
  #|pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit
  #|
  #|pub fn[{{#clients}}H{{client_index}} : {{trait_name}}{{^is_last}}, {{/is_last}}{{/clients}}] create_router(
  #|  {{#clients}}{{handler_var}}~ : H{{client_index}},
  #|  {{/clients}}
  #|) -> Router {
  #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) {
  #|    let full_path = req.path
  #|    let path = strip_request_query(full_path)
  #|    if false { () }
  #|    {{#clients}}
  #|      {{#methods}}
  #|    else if req.meth == {{http_meth_token}} && match_path_template("{{{path_template}}}", path) {
  #|      {{#has_body}}let body_bytes = body_stream.read_all()
  #|      let body_str = body_bytes.text()
  #|      {{/has_body}}
  #|      {{^has_body}}ignore(body_stream)
  #|      {{/has_body}}
  #|      {{#params}}
  #|      {{#isBody}}{{#isString}}let {{var_name}} = body_str{{/isString}}{{^isString}}let {{var_name}} : {{type_str}} = try { @json.from_json(@json.parse(body_str)) } catch { _ => @json.from_json(null) }{{/isString}}{{/isBody}}
  #|      {{#isPath}}let {{var_name}} = get_path_param("{{{path_template}}}", path, "{{wire_name}}"){{/isPath}}
  #|      {{#isHeader}}let {{var_name}} = get_header(req.headers, "{{wire_name}}"){{/isHeader}}
  #|      {{#isQuery}}let {{var_name}} = get_query_param(full_path, "{{wire_name}}"){{/isQuery}}
  #|      {{^isBody}}{{^isPath}}{{^isHeader}}{{^isQuery}}let {{var_name}} = ""{{/isQuery}}{{/isHeader}}{{/isPath}}{{/isBody}}
  #|      {{/params}}
  #|      {{#has_response_body}}let resp_body = {{{handler_var}}}.{{handler_method}}({{#params}}{{var_name}}{{^is_last}}, {{/is_last}}{{/params}})
  #|      let headers : Map[String, String] = { "content-type": "application/json" }
  #|      conn.send_response({{status_code}}, "{{reason_phrase}}", extra_headers=headers)
  #|      conn.write(resp_body.to_json().stringify())
  #|      conn.end_response()
  #|      {{/has_response_body}}
  #|      {{^has_response_body}}{{{handler_var}}}.{{handler_method}}({{#params}}{{var_name}}{{^is_last}}, {{/is_last}}{{/params}})
  #|      conn.send_response({{status_code}}, "{{reason_phrase}}")
  #|      conn.end_response()
  #|      {{/has_response_body}}
  #|    }
  #|      {{/methods}}
  #|    {{/clients}}
  #|    else {
  #|      conn.send_response(404, "NotFound")
  #|      conn.write("not found")
  #|      conn.end_response()
  #|    }
  #|  }
  #|}
  #|

///|
fn status_reason_phrase(code : Int) -> String {
  if code == 200 {
    "OK"
  } else if code == 201 {
    "Created"
  } else if code == 202 {
    "Accepted"
  } else if code == 204 {
    "No Content"
  } else if code == 400 {
    "Bad Request"
  } else if code == 401 {
    "Unauthorized"
  } else if code == 403 {
    "Forbidden"
  } else if code == 404 {
    "Not Found"
  } else if code == 409 {
    "Conflict"
  } else if code == 500 {
    "Internal Server Error"
  } else {
    "OK"
  }
}

///|
fn emit_create_router(crate : @codemodel.Crate) -> String raise {
  fn compact_alpha_digit_underscore(s : String) -> String {
    let n = s.length()
    let sb = StringBuilder::new(size_hint=n)
    let mut i = 0
    while i < n {
      let ch = s.code_unit_at(i)
      if ch == '_' && i > 0 && i + 1 < n {
        let prev = s.code_unit_at(i - 1)
        let next = s.code_unit_at(i + 1)
        let prev_is_lower = prev >= 'a' && prev <= 'z'
        let next_is_digit = next >= '0' && next <= '9'
        if prev_is_lower && next_is_digit {
          i += 1
          continue
        }
      }
      sb.write_char(ch.to_int().unsafe_to_char())
      i += 1
    }
    sb.to_string()
  }

  let clients = crate.clients
  let mut op_counter = 0
  let used_handler_vars : Array[String] = Array::new()
  let clients_ctx : Array[Json] = Array::new()
  for i in 0..<clients.length() {
    let client = clients[i]
    let methods_arr : Array[Json] = Array::new()
    for op in client.methods {
      op_counter += 1
      let meth = server_meth_ctor(op.http_method)
      let normalized_tmpl = normalize_uri_template(op.path)
      let tmpl = normalized_tmpl
        .replace_all(old="\\", new="\\\\")
        .replace_all(old="\"", new="\\\"")

      // detect body presence
      let has_body = for param in op.parameters {
        if param.location == "body" {
          break true
        }
      } else {
        false
      }
      let params_arr = Array::new()
      let param_count = op.parameters.length()
      for j in 0..<param_count {
        let param = op.parameters[j]
        let pname = sanitize_identifier(@case.snake_case(param.name))
        let var_name = "p_\{op_counter}_\{pname}"
        let type_str = type_ref_to_string(param.type_)
        let param_ctx : Json = {
          "name": @case.snake_case(param.name),
          "wire_name": param.name,
          "var_name": var_name,
          "location": param.location,
          "type_str": type_str,
          "isBody": param.location == "body",
          "isPath": param.location == "path",
          "isHeader": param.location == "header",
          "isQuery": param.location == "query",
          "isString": type_str == "String",
          "is_last": j == param_count - 1,
        }
        params_arr.push(param_ctx)
      }
      let has_response_body = op.response_body is Some(_)
      let return_type = match op.response_body {
        Some(t) => type_ref_to_string(t)
        None => "Unit"
      }
      methods_arr.push({
        "method_name": @case.snake_case(op.name),
        "handler_method": @case.snake_case(op.name),
        "http_meth_token": meth,
        "path_template": tmpl,
        "has_body": has_body,
        "status_code": op.status_code.to_double(),
        "reason_phrase": status_reason_phrase(op.status_code),
        "has_response_body": has_response_body,
        "return_type": return_type,
        "params": params_arr,
      })
    }
    clients_ctx.push({
      "handler_var": {
        let base = {
          let s = compact_alpha_digit_underscore(
            sanitize_identifier(@case.snake_case(client.name)),
          )
          if s == "" {
            "h\{i}"
          } else {
            "\{s}_handler"
          }
        }
        let mut candidate = base
        let mut suffix = 1
        while true {
          let mut exists = false
          for name in used_handler_vars {
            if name == candidate {
              exists = true
              break
            }
          }
          if !exists {
            break
          }
          candidate = "\{base}_\{suffix}"
          suffix += 1
        }
        used_handler_vars.push(candidate)
        candidate
      },
      "trait_name": @case.pascal_case(sanitize_identifier(client.name)) +
      "Handler",
      "client_index": i.to_double(),
      "is_last": i == clients.length() - 1,
      "methods": methods_arr,
    })
  }
  @mustache.parse(router_template, { "clients": clients_ctx })
}

///|
test "emit_server_router" {
  let crate : @codemodel.Crate = {
    name: "test_crate",
    version: "0.1.0",
    clients: [
      @codemodel.Client::{
        name: "TestClient",
        methods: [
          @codemodel.Method::{
            name: "GetItem",
            http_method: "GET",
            path: "/items/{itemId}",
            status_code: 200,
            response_body: None,
            parameters: [
              @codemodel.Parameter::{
                name: "itemId",
                location: "path",
                type_: @codemodel.TypeRef::String,
              },
            ],
          },
          @codemodel.Method::{
            name: "CreateItem",
            http_method: "POST",
            path: "/items",
            status_code: 200,
            response_body: None,
            parameters: [
              @codemodel.Parameter::{
                name: "body",
                location: "body",
                type_: @codemodel.TypeRef::Model(@codemodel.Model::{
                  name: "Item",
                  fields: [
                    @codemodel.ModelField::{
                      name: "name",
                      type_: @codemodel.TypeRef::String,
                      optional: false,
                    },
                  ],
                }),
              },
            ],
          },
        ],
      },
    ],
  }
  let router_code = emit_server_router(crate)
  inspect(
    router_code,
    content=(
      #|
      #|///|
      #|/// Traits for operation handlers
      #|pub(open) trait TestClientHandler {
      #|  async get_item(Self, item_id : String) -> Unit
      #|  async create_item(Self, body : Item) -> Unit
      #|  
      #|}
      #|pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit
      #|
      #|pub fn[H0 : TestClientHandler] create_router(
      #|  test_client_handler~ : H0,
      #|  
      #|) -> Router {
      #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) {
      #|    let full_path = req.path
      #|    let path = strip_request_query(full_path)
      #|    if false { () }
      #|    
      #|      
      #|    else if req.meth == @http.Get && match_path_template("/items/{itemId}", path) {
      #|      
      #|      ignore(body_stream)
      #|      
      #|      
      #|      
      #|      let p_1_item_id = get_path_param("/items/{itemId}", path, "itemId")
      #|      
      #|      
      #|      
      #|      
      #|      
      #|      test_client_handler.get_item(p_1_item_id)
      #|      conn.send_response(200, "OK")
      #|      conn.end_response()
      #|      
      #|    }
      #|      
      #|    else if req.meth == @http.Post && match_path_template("/items", path) {
      #|      let body_bytes = body_stream.read_all()
      #|      let body_str = body_bytes.text()
      #|      
      #|      
      #|      
      #|      let p_2_body : Item = try { @json.from_json(@json.parse(body_str)) } catch { _ => @json.from_json(null) }
      #|      
      #|      
      #|      
      #|      
      #|      
      #|      
      #|      test_client_handler.create_item(p_2_body)
      #|      conn.send_response(200, "OK")
      #|      conn.end_response()
      #|      
      #|    }
      #|      
      #|    
      #|    else {
      #|      conn.send_response(404, "NotFound")
      #|      conn.write("not found")
      #|      conn.end_response()
      #|    }
      #|  }
      #|}
      #|
    ),
  )
}

///|
fn emit_server_router(crate : @codemodel.Crate) -> String raise {
  let buf = StringBuilder::new(size_hint=8192)
  // 1. Generate Handler Traits

  let clients_json = crate.clients.map(fn(client) -> Json {
    let methods = client.methods.map(fn(op) -> Json {
      let params = op.parameters.map(fn(p) -> Json {
        {
          "name": @case.snake_case(p.name),
          "type": type_ref_to_string(p.type_),
        }
      })
      let return_type = match op.response_body {
        Some(t) => type_ref_to_string(t)
        None => "Unit"
      }
      {
        "method_name": @case.snake_case(op.name),
        "return_type": return_type,
        "params": params,
      }
    })
    {
      "trait_name": @case.pascal_case(client.name) + "Handler",
      "methods": methods,
    }
  })
  buf.write_string(
    @mustache.parse(handler_trait_template, { "clients": clients_json }),
  )
  // 2. Generate Router
  buf.write_string(emit_create_router(crate))
  buf.to_string()
}

///|
fn analyze_router_helper_needs(crate : @codemodel.Crate) -> (Bool, Bool, Bool) {
  let mut need_path_param = false
  let mut need_header = false
  let mut need_query = false
  for client in crate.clients {
    for op in client.methods {
      for p in op.parameters {
        if p.location == "path" {
          need_path_param = true
        } else if p.location == "header" {
          need_header = true
        } else if p.location == "query" {
          need_query = true
        }
      }
    }
  }
  (need_path_param, need_header, need_query)
}

///|
fn emit_server_router_helpers(crate : @codemodel.Crate) -> String {
  let buf = StringBuilder::new(size_hint=2048)
  let (need_path_param, need_header, need_query) = analyze_router_helper_needs(
    crate,
  )
  buf.write_string(strip_request_query_code)
  buf.write_string(match_path_template_code)
  if need_path_param {
    buf.write_string(get_path_param_code)
  }
  if need_header {
    buf.write_string(get_header_code)
  }
  if need_query {
    buf.write_string(get_query_param_code)
  }
  buf.to_string()
}

///|
test "emit_server_router_helpers" {
  let crate : @codemodel.Crate = {
    name: "test_crate",
    version: "0.1.0",
    clients: [
      @codemodel.Client::{
        name: "TestClient",
        methods: [
          @codemodel.Method::{
            name: "GetItem",
            http_method: "GET",
            path: "/items/{itemId}",
            status_code: 200,
            response_body: None,
            parameters: [
              @codemodel.Parameter::{
                name: "itemId",
                location: "path",
                type_: @codemodel.TypeRef::String,
              },
            ],
          },
        ],
      },
    ],
  }
  let helpers_code = emit_server_router_helpers(crate)
  inspect(
    helpers_code,
    content=(
      #|///|
      #|fn strip_request_query(path : String) -> String {
      #|  let parts = path.split("?").to_array()
      #|  if parts.length() == 0 { path } else { parts[0].to_string() }
      #|}
      #|///|
      #|fn match_path_template(template : String, path : String) -> Bool {
      #|  let tlen = template.length()
      #|  let plen = path.length()
      #|  let mut ti = 0
      #|  let mut pi = 0
      #|  while ti < tlen && pi < plen {
      #|    if template.code_unit_at(ti) == '{' {
      #|      // find matching `}` in template
      #|      let mut close = ti + 1
      #|      while close < tlen && template.code_unit_at(close) != '}' {
      #|        close += 1
      #|      }
      #|      if close >= tlen {
      #|        return false
      #|      }
      #|      // match a non-empty path segment
      #|      let seg_start = pi
      #|      while pi < plen && path.code_unit_at(pi) != '/' {
      #|        pi += 1
      #|      }
      #|      if pi == seg_start {
      #|        return false
      #|      }
      #|      ti = close + 1
      #|    } else {
      #|      if template.code_unit_at(ti) != path.code_unit_at(pi) {
      #|        return false
      #|      }
      #|      ti += 1
      #|      pi += 1
      #|    }
      #|  }
      #|  ti == tlen && pi == plen
      #|}
      #|///|
      #|fn get_path_param(template : String, path : String, name : String) -> String {
      #|  let tlen = template.length()
      #|  let plen = path.length()
      #|  let mut ti = 0
      #|  let mut pi = 0
      #|  while ti < tlen && pi < plen {
      #|    if template.code_unit_at(ti) == '{' {
      #|      let mut close = ti + 1
      #|      while close < tlen && template.code_unit_at(close) != '}' {
      #|        close += 1
      #|      }
      #|      if close >= tlen {
      #|        return ""
      #|      }
      #|      let key_sb = StringBuilder::new(size_hint=close - (ti + 1))
      #|      for k in (ti + 1)..<close {
      #|        key_sb.write_char(template.code_unit_at(k).to_int().unsafe_to_char())
      #|      }
      #|      let key = key_sb.to_string()
      #|      let seg_start = pi
      #|      while pi < plen && path.code_unit_at(pi) != '/' {
      #|        pi += 1
      #|      }
      #|      if key == name {
      #|        let seg_sb = StringBuilder::new(size_hint=pi - seg_start)
      #|        for k in seg_start..<pi {
      #|          seg_sb.write_char(path.code_unit_at(k).to_int().unsafe_to_char())
      #|        }
      #|        return seg_sb.to_string()
      #|      }
      #|      ti = close + 1
      #|    } else {
      #|      if template.code_unit_at(ti) != path.code_unit_at(pi) {
      #|        return ""
      #|      }
      #|      ti += 1
      #|      pi += 1
      #|    }
      #|  }
      #|  ""
      #|}
      #|

    ),
  )
}

///|
let strip_request_query_code =
  #|///|
  #|fn strip_request_query(path : String) -> String {
  #|  let parts = path.split("?").to_array()
  #|  if parts.length() == 0 { path } else { parts[0].to_string() }
  #|}
  #|

///|
let match_path_template_code =
  #|///|
  #|fn match_path_template(template : String, path : String) -> Bool {
  #|  let tlen = template.length()
  #|  let plen = path.length()
  #|  let mut ti = 0
  #|  let mut pi = 0
  #|  while ti < tlen && pi < plen {
  #|    if template.code_unit_at(ti) == '{' {
  #|      // find matching `}` in template
  #|      let mut close = ti + 1
  #|      while close < tlen && template.code_unit_at(close) != '}' {
  #|        close += 1
  #|      }
  #|      if close >= tlen {
  #|        return false
  #|      }
  #|      // match a non-empty path segment
  #|      let seg_start = pi
  #|      while pi < plen && path.code_unit_at(pi) != '/' {
  #|        pi += 1
  #|      }
  #|      if pi == seg_start {
  #|        return false
  #|      }
  #|      ti = close + 1
  #|    } else {
  #|      if template.code_unit_at(ti) != path.code_unit_at(pi) {
  #|        return false
  #|      }
  #|      ti += 1
  #|      pi += 1
  #|    }
  #|  }
  #|  ti == tlen && pi == plen
  #|}
  #|

///|
let get_path_param_code =
  #|///|
  #|fn get_path_param(template : String, path : String, name : String) -> String {
  #|  let tlen = template.length()
  #|  let plen = path.length()
  #|  let mut ti = 0
  #|  let mut pi = 0
  #|  while ti < tlen && pi < plen {
  #|    if template.code_unit_at(ti) == '{' {
  #|      let mut close = ti + 1
  #|      while close < tlen && template.code_unit_at(close) != '}' {
  #|        close += 1
  #|      }
  #|      if close >= tlen {
  #|        return ""
  #|      }
  #|      let key_sb = StringBuilder::new(size_hint=close - (ti + 1))
  #|      for k in (ti + 1)..<close {
  #|        key_sb.write_char(template.code_unit_at(k).to_int().unsafe_to_char())
  #|      }
  #|      let key = key_sb.to_string()
  #|      let seg_start = pi
  #|      while pi < plen && path.code_unit_at(pi) != '/' {
  #|        pi += 1
  #|      }
  #|      if key == name {
  #|        let seg_sb = StringBuilder::new(size_hint=pi - seg_start)
  #|        for k in seg_start..<pi {
  #|          seg_sb.write_char(path.code_unit_at(k).to_int().unsafe_to_char())
  #|        }
  #|        return seg_sb.to_string()
  #|      }
  #|      ti = close + 1
  #|    } else {
  #|      if template.code_unit_at(ti) != path.code_unit_at(pi) {
  #|        return ""
  #|      }
  #|      ti += 1
  #|      pi += 1
  #|    }
  #|  }
  #|  ""
  #|}
  #|

///|
let get_header_code =
  #|///|
  #|fn get_header(headers : Map[String, String], name : String) -> String {
  #|  match headers.get(name.to_lower().to_string()) {
  #|    Some(v) => v
  #|    None => ""
  #|  }
  #|}
  #|

///|
let get_query_param_code =
  #|///|
  #|fn get_query_param(full_path : String, name : String) -> String {
  #|  let parts = full_path.split("?").to_array()
  #|  if parts.length() < 2 { return "" }
  #|  let query = parts[1].to_string()
  #|  for pair in query.split("&") {
  #|    let kv = pair.split("=").to_array()
  #|    if kv.length() >= 2 {
  #|      if kv[0].to_string() == name { return kv[1].to_string() }
  #|    }
  #|  }
  #|  ""
  #|}
  #|

///|
fn collect_models(
  type_ : @codemodel.TypeRef,
  models : Map[String, @codemodel.Model],
) -> Unit {
  match type_ {
    Model(m) =>
      if !models.contains(m.name) {
        models.set(m.name, m)
        for field in m.fields {
          collect_models(field.type_, models)
        }
      }
    Array(t) => collect_models(t, models)
    Record(t) => collect_models(t, models)
    Nullable(t) => collect_models(t, models)
    _ => ()
  }
}

///|
fn server_meth_ctor(http_method : String) -> String {
  match http_method.to_upper() {
    "GET" => "@http.Get"
    "HEAD" => "@http.Head"
    "POST" => "@http.Post"
    "PUT" => "@http.Put"
    "DELETE" => "@http.Delete"
    "PATCH" => "@http.Patch"
    "OPTIONS" => "@http.Options"
    "TRACE" => "@http.Trace"
    "CONNECT" => "@http.Connect"
    _ => "@http.Get"
  }
}

///|
fn normalize_uri_template(template : String) -> String {
  let p1 = template.split("{?").to_array()
  let s = if p1.length() == 0 { template } else { p1[0].to_string() }
  let p2 = s.split("?").to_array()
  if p2.length() == 0 {
    s
  } else {
    p2[0].to_string()
  }
}
