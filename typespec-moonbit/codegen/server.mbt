/// Server 代码生成模块：生成基于 `moonbitlang/async/http` 的 server 包。

///|
/// 生成 server 包的文件列表。
pub fn emit_server_files(crate : @codemodel.Crate) -> Array[OutputFile] raise {
  let files = Array::new(capacity=3)
  files.push(OutputFile::new("moon.pkg.json", emit_server_moon_pkg_json()))
  files.push(OutputFile::new("README.mbt.md", emit_server_readme(crate)))
  files.push(OutputFile::new("router.mbt", emit_server_router(crate)))
  files
}

///|
fn emit_server_moon_pkg_json() -> String {
  (
    #|{
    #|  "import": [
    #|    "moonbitlang/async/http",
    #|    "moonbitlang/async/io"
    #|  ]
    #|}
  )
}

///|
fn emit_server_readme(crate : @codemodel.Crate) -> String {
  (
    $|# \{crate.name()}
    $|
    $|Generated by typespec-moonbit.
    $|
    $|This MoonBit package can be imported by other packages to start a server.
  )
}

///|
fn emit_server_router(crate : @codemodel.Crate) -> String raise {
  let buf = StringBuilder::new(size_hint=8192)

  // 1. Collect Models
  let models = Map::new()
  for client in crate.clients() {
    for op in client.methods() {
      for param in op.parameters() {
        collect_models(param.type_(), models)
      }
    }
  }

  // 2. Generate Model Structs
  let model_list = models.to_array()
  model_list.sort_by_key(fn(m) { m.0 })
  let models_json = model_list.map(fn(item) {
    let m = item.1
    let fields = m.fields.map(fn(f) {
      Json::object({
        "name": Json::string(@case.snake_case(f.name)),
        "type": Json::string(type_ref_to_string(f.type_)),
      })
    })
    Json::object({
      "name": Json::string(m.name),
      "struct_name": Json::string(@case.pascal_case(m.name)),
      "fields": Json::array(fields),
    })
  })
  buf.write_string(
    @mustache.parse(
      model_template,
      Json::object({ "models": Json::array(models_json) }),
    ),
  )

  // 3. Generate Handler Traits

  let clients_json = crate
    .clients()
    .map(fn(client) {
      let methods = client
        .methods()
        .map(fn(op) {
          let params = op
            .parameters()
            .map(fn(p) {
              Json::object({
                "name": Json::string(@case.snake_case(p.name)),
                "type": Json::string(type_ref_to_string(p.type_)),
              })
            })
          Json::object({
            "method_name": Json::string(@case.snake_case(op.name())),
            "params": Json::array(params),
          })
        })
      Json::object({
        "trait_name": Json::string(@case.pascal_case(client.name()) + "Handler"),
        "methods": Json::array(methods),
      })
    })
  buf.write_string(
    @mustache.parse(
      handler_trait_template,
      Json::object({ "clients": Json::array(clients_json) }),
    ),
  )

  // 4. Generate Router Struct and Factory
  buf.write_string(
    (
      $|pub struct Router {
      $|  dispatch : async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit
      $|}
      $|
    ),
  )
  buf.write_string(
    (
      $|pub async fn Router::dispatch(
      $|  self : Router,
      $|  request : @http.Request,
      $|  body : &@io.Reader,
      $|  conn : @http.ServerConnection
      $|) -> Unit {
      $|  (self.dispatch)(request, body, conn)
      $|}
      $|
    ),
  )
  let clients = crate.clients()
  let traits = clients
    .mapi(fn(i, c) {
      let trait_name = @case.pascal_case(sanitize_identifier(c.name())) +
        "Handler"
      "H\{i} : \{trait_name}"
    })
    .join(",")
  let params = clients.mapi(fn(i, _) { "h\{i} : H\{i}" }).join(",")
  buf.write_string(
    (
      $|pub fn[\{traits}] create_router(\{params}) -> Router {
      $|  Router::{
      $|    dispatch: async fn(req, body_stream, conn) {
      $|      let path = strip_request_query(req.path)
      $|      if false { () }
    ),
  )
  let mut op_counter = 0
  for i in 0..<clients.length() {
    let client = clients[i]
    for op in client.methods() {
      op_counter += 1
      let meth = server_meth_ctor(op.http_method())
      let normalized_tmpl = normalize_uri_template(op.path())
      let tmpl = normalized_tmpl
        .replace_all(old="\\", new="\\\\")
        .replace_all(old="\"", new="\\\"")
      buf.write_string(
        "      else if req.meth == \{meth} && match_path_template(\"\{tmpl}\", path) {\n",
      )

      // Parse body if and only if there's a body parameter
      let mut has_body = false
      for param in op.parameters() {
        if param.location == "body" {
          has_body = true
        }
      }
      if has_body {
        buf.write_string("        let body_bytes = body_stream.read_all()\n")
        buf.write_string("        let body_str = body_bytes.text()\n")
      } else {
        buf.write_string("        ignore(body_stream)\n")
      }
      let args = Array::new()
      for param in op.parameters() {
        let pname = sanitize_identifier(@case.snake_case(param.name))
        let var_name = "p_\{op_counter}_\{pname}"
        match param.location {
          "body" => {
            let type_str = type_ref_to_string(param.type_)
            if type_str == "String" {
              buf.write_string("        let \{var_name} = body_str\n")
            } else {
              buf.write_string(
                "        let \{var_name} : \{type_str} = try { @json.from_json(@json.parse(body_str)) } catch { _ => @json.from_json(null) }\n",
              )
            }
          }
          "query" => buf.write_string("        let \{var_name} = \"\"\n") // TODO: implement query parser
          _ => buf.write_string("        let \{var_name} = \"\"\n")
        }
        args.push(var_name)
      }
      let args_str = args.join(", ")
      buf.write_string(
        "        h\{i}.\{@case.snake_case(op.name())}(\{args_str})\n",
      )
      buf.write_string("        conn.send_response(204, \"No Content\")\n")
      buf.write_string("      }\n")
    }
  }
  buf.write_string("      else {\n")
  buf.write_string("        conn.send_response(404, \"NotFound\")\n")
  buf.write_string("        conn.write(\"not found\")\n")
  buf.write_string("      }\n")
  buf.write_string("    }\n")
  buf.write_string("  }\n")
  buf.write_string("}\n\n")
  buf.write_string(strip_request_query_code)
  buf.write_string(match_path_template_code)
  buf.to_string()
}

///|
let strip_request_query_code =
  #|///|
  #|fn strip_request_query(path : String) -> String {
  #|  let parts = path.split("?").to_array()
  #|  if parts.length() == 0 { path } else { parts[0].to_string() }
  #|}
  #|

///|
let match_path_template_code =
  #|///|
  #|fn match_path_template(template : String, path : String) -> Bool {
  #|  let t = template.trim(char_set="/")
  #|  let p = path.trim(char_set="/")
  #|  let t_segs = if t == "" { [] } else { t.split("/").to_array() }
  #|  let p_segs = if p == "" { [] } else { p.split("/").to_array() }
  #|  if t_segs.length() != p_segs.length() { return false }
  #|  for i in 0..<t_segs.length() {
  #|    let ts = t_segs[i].to_string()
  #|    let ps = p_segs[i].to_string()
  #|    if ts.length() >= 2 && ts.has_prefix("{") && ts.has_suffix("}") {
  #|      if ps == "" { return false }
  #|    } else if ts != ps { return false }
  #|  }
  #|  true
  #|}
  #|

///|
fn collect_models(
  type_ : @codemodel.TypeRef,
  models : Map[String, @codemodel.Model],
) -> Unit {
  match type_ {
    Model(m) =>
      if !models.contains(m.name) {
        models.set(m.name, m)
        for field in m.fields {
          collect_models(field.type_, models)
        }
      }
    Array(t) => collect_models(t, models)
    _ => ()
  }
}

///|
fn type_ref_to_string(type_ : @codemodel.TypeRef) -> String {
  match type_ {
    String => "String"
    Int32 => "Int"
    Int64 => "Int64"
    Float64 => "Double"
    Bool => "Bool"
    Model(m) => @case.pascal_case(m.name)
    Array(t) => "Array[\{type_ref_to_string(t)}]"
  }
}

///|
fn server_meth_ctor(http_method : String) -> String {
  match http_method.to_upper() {
    "GET" => "@http.Get"
    "HEAD" => "@http.Head"
    "POST" => "@http.Post"
    "PUT" => "@http.Put"
    "DELETE" => "@http.Delete"
    "PATCH" => "@http.Patch"
    "OPTIONS" => "@http.Options"
    "TRACE" => "@http.Trace"
    "CONNECT" => "@http.Connect"
    _ => "@http.Get"
  }
}

///|
fn normalize_uri_template(template : String) -> String {
  let p1 = template.split("{?").to_array()
  let s = if p1.length() == 0 { template } else { p1[0].to_string() }
  let p2 = s.split("?").to_array()
  if p2.length() == 0 {
    s
  } else {
    p2[0].to_string()
  }
}
