/// Server 代码生成模块：生成基于 `moonbitlang/async/http` 的 server 包。

///|
/// 生成 server 包的文件列表。
pub fn emit_server_files(crate : @codemodel.Crate) -> Array[OutputFile] raise {
  let has_sse = crate.clients
    .iter()
    .flat_map(fn(c) { c.methods.iter() })
    .any(fn(m) { m.is_sse })
  [
    OutputFile::new("moon.pkg.json", emit_server_moon_pkg_json()),
    OutputFile::new("README.mbt.md", emit_server_readme(crate)),
    OutputFile::new("models.mbt", emit_server_models(crate)),
    OutputFile::new("router.mbt", emit_server_router(crate)),
    OutputFile::new("router_helpers.mbt", emit_server_router_helpers(crate)),
  ] +
  (if has_sse {
    [OutputFile::new("event_stream.mbt", emit_server_event_stream())]
  } else {
    []
  })
}

///|
fn emit_server_moon_pkg_json() -> String {
  (
    #|{
    #|  "import": [
    #|    "moonbitlang/async",
    #|    "moonbitlang/async/http",
    #|    "moonbitlang/async/io",
    #|    "moonbitlang/core/json"
    #|  ]
    #|}
  )
}

///|
fn emit_server_readme(crate : @codemodel.Crate) -> String {
  (
    $|# \{crate.name}
    $|
    $|Generated by typespec-moonbit.
    $|
    $|This MoonBit package can be imported by other packages to start a server.
  )
}

///|
fn emit_server_event_stream() -> String {
  server_event_stream_code
}

///|
let server_event_stream_code : String =
  #|///|
  #|/// Server-Sent Events (SSE) 工具。
  #|///
  #|/// 提供 `text/event-stream` 响应的写入封装，方便 handler 端持续推送事件。
  #|pub struct EventStreamWriter {
  #|  conn : @http.ServerConnection
  #|}
  #|
  #|///|
  #|fn sse_default_headers() -> Map[String, String] {
  #|  {
  #|    "content-type": "text/event-stream",
  #|    "cache-control": "no-cache",
  #|    "connection": "keep-alive",
  #|    "x-accel-buffering": "no",
  #|  }
  #|}
  #|
  #|///|
  #|/// 启动 SSE 响应并返回写入器。
  #|pub async fn EventStreamWriter::start(
  #|  conn : @http.ServerConnection,
  #|  status : Int,
  #|  reason : String,
  #|  extra_headers? : Map[String, String] = {},
  #|) -> EventStreamWriter {
  #|  let headers = sse_default_headers()
  #|  for k, v in extra_headers {
  #|    headers.set(k, v)
  #|  }
  #|  conn.send_response(status, reason, extra_headers=headers)
  #|  EventStreamWriter::{ conn }
  #|}
  #|
  #|///|
  #|/// 发送一条 SSE event（按 SSE 行协议拼装）。
  #|pub async fn EventStreamWriter::write_event(
  #|  self : EventStreamWriter,
  #|  id? : String,
  #|  event? : String,
  #|  data? : &@io.Data,
  #|  flush? : Bool = true,
  #|) -> Unit {
  #|  if event is Some(event) {
  #|    self.conn.write("event: \{event}\n")
  #|  }
  #|  if data is Some(data) {
  #|    self.conn.write(b"data: ")
  #|    self.conn.write(data)
  #|    self.conn.write(b"\n")
  #|  }
  #|  if id is Some(id) {
  #|    self.conn.write("id: \{id}\n")
  #|  }
  #|  self.conn.write(b"\n")
  #|  if flush {
  #|    self.conn.flush()
  #|  }
  #|}
  #|
  #|///|
  #|/// 表示一条 SSE 事件（便于业务类型转换）。
  #|pub struct SseEvent {
  #|  event : String?
  #|  data : String
  #|} derive(ToJson)
  #|
  #|///|
  #|pub fn SseEvent::new(event? : String, data~ : String) -> SseEvent {
  #|  SseEvent::{ event, data }
  #|}
  #|
  #|///|
  #|/// 将业务类型转换为 SSE 事件。
  #|pub(open) trait SseToEvent {
  #|  to_event(self : Self) -> SseEvent
  #|}
  #|
  #|///|
  #|/// 将实现了 `SseToEvent` 的事件写入 SSE stream。
  #|pub async fn[T : SseToEvent] EventStreamWriter::write(
  #|  self : EventStreamWriter,
  #|  event : T,
  #|  flush? : Bool = true,
  #|) -> Unit {
  #|  let sse_event = event.to_event()
  #|  self.write_event(event?=sse_event.event, data=sse_event.data, flush~)
  #|}
  #|

///|
let model_template : String =
  #|{{#models}}
  #|///|
  #|/// Model {{name}}
  #|pub(all) struct {{struct_name}} {
  #|{{#fields}}
  #|  {{field_name}} : {{type}}{{#optional}}?{{/optional}}
  #|{{/fields}}
  #|} derive(Show, Default, {{^has_renames}}ToJson{{/has_renames}}{{#has_renames}}ToJson(fields({{#field_renames}}{{field_name}}(rename="{{wire_name}}"){{^is_last}}, {{/is_last}}{{/field_renames}})){{/has_renames}}{{#derive_fromjson}}, {{^has_renames}}@json.FromJson{{/has_renames}}{{#has_renames}}@json.FromJson(fields({{#field_renames}}{{field_name}}(rename="{{wire_name}}"){{^is_last}}, {{/is_last}}{{/field_renames}})){{/has_renames}}{{/derive_fromjson}})
  #|
  #|{{/models}}

///|
let union_template : String =
  #|{{#unions}}
  #|///|
  #|/// Union {{name}}
  #|pub(all) enum {{enum_name}} {
  #|  {{#variants}}{{ctor_name}}({{type}}){{^is_last}}
  #|  {{/is_last}}{{/variants}}
  #|} derive(Show)
  #|
  #|///|
  #|pub impl Default for {{enum_name}} with default() {
  #|  {{default_ctor}}({{default_ctor_type}}::default())
  #|}
  #|
  #|///|
  #|pub impl ToJson for {{enum_name}} with to_json(self : {{enum_name}}) -> Json {
  #|  match self {
  #|    {{#variants}}{{ctor_name}}(v) => v.to_json(){{^is_last}}
  #|    {{/is_last}}{{/variants}}
  #|  }
  #|}
  #|
  #|{{/unions}}

///|
let handler_trait_template : String =
  #|{{#clients}}
  #|///|
  #|/// Traits for operation handlers
  #|pub(open) trait {{trait_name}} {
  #|  {{#methods}}async {{method_name}}(Self, group~ : @async.TaskGroup[Unit]{{#params}}, {{name}} : {{type}}{{/params}}{{#is_sse}}, sse : EventStreamWriter{{/is_sse}}) -> {{return_type}}
  #|  {{/methods}}
  #|}
  #|{{/clients}}

///|
let nullable_support_code : String =
  #|///|
  #|/// Nullable helper used for `T | null`.
  #|pub(all) struct Nullable[T](T?) derive(Show, Default, Eq, Compare)
  #|
  #|///|
  #|pub impl[T : ToJson] ToJson for Nullable[T] with to_json(self : Nullable[T]) -> Json {
  #|  match self.0 {
  #|    Some(v) => v.to_json()
  #|    None => Json::null()
  #|  }
  #|}
  #|
  #|///|
  #|pub impl[T : @json.FromJson] @json.FromJson for Nullable[T] with from_json(
  #|  j : Json,
  #|  path : @json.JsonPath,
  #|) -> Nullable[T] raise @json.JsonDecodeError {
  #|  match j {
  #|    Null => Nullable(None)
  #|    _ => Nullable(Some(@json.from_json(j, path~)))
  #|  }
  #|}
  #|

///|
fn emit_server_models(crate : @codemodel.Crate) -> String raise {
  let buf = StringBuilder::new(size_hint=8192)

  // 1. Collect Models and Unions
  let decode_models = collect_decode_models_from_crate(crate)
  let (encode_models, encode_unions) = collect_encode_types_from_crate(crate)
  let models = Map::new()
  for k, v in encode_models {
    models.set(k, v)
  }
  for k, v in decode_models {
    models.set(k, v)
  }

  // 2. Nullable helper (for `T | null`)
  buf.write_string(nullable_support_code)

  // 3. Generate Union Enums (ToJson only)
  let union_list = encode_unions.to_array()
  union_list.sort_by_key(fn(u) { u.0 })
  let unions_json = union_list.map(fn(item) -> Json {
    let u = item.1
    let variants_json : Array[Json] = Array::new()
    let n = u.variants.length()
    for i in 0..<n {
      let v = u.variants[i]
      let variant_json : Json = {
        "ctor_name": @case.pascal_case(sanitize_identifier(v.name)),
        "type": type_ref_to_string(v.type_),
        "is_last": i == n - 1,
      }
      variants_json.push(variant_json)
    }
    let default_variant = if n > 0 {
      u.variants[0]
    } else {
      // 不应出现空 union；保持生成结果可编译，默认到 Json。
      @codemodel.UnionVariant::{
        name: "Default",
        type_: @codemodel.TypeRef::Json,
      }
    }
    {
      "name": u.name,
      "enum_name": @case.pascal_case(u.name),
      "variants": variants_json,
      "default_ctor": @case.pascal_case(
        sanitize_identifier(default_variant.name),
      ),
      "default_ctor_type": type_ref_to_string(default_variant.type_),
    }
  })
  buf.write_string(@mustache.parse(union_template, { "unions": unions_json }))

  // 4. Generate Model Structs
  let model_list = models.to_array()
  model_list.sort_by_key(fn(m) { m.0 })
  let models_json = model_list.map(fn(item) -> Json {
    let m = item.1
    // Build snake_case MoonBit field names, but keep JSON keys as original TypeSpec field names.
    // NOTE: 不考虑 @encodedName；wire name 直接用 TypeSpec property.name。
    //
    // 为避免歧义，若两个字段映射到同一个 snake_case 标识符，直接报错。
    let seen_field_names : Map[String, String] = Map::new() // field_name -> wire_name
    let fields_json : Array[Json] = Array::new()
    let rename_entries : Array[(String, String)] = Array::new()
    for i in 0..<m.fields.length() {
      let f = m.fields[i]
      let field_name = sanitize_identifier(@case.snake_case(f.name))
      if seen_field_names.contains(field_name) {
        let prev = seen_field_names.get(field_name).unwrap()
        if prev != f.name {
          raise Failure::Failure(
            "model field name collision after snake_case: \{m.name}.\{prev} and \{m.name}.\{f.name} both map to \{field_name}",
          )
        }
      } else {
        seen_field_names.set(field_name, f.name)
      }
      fields_json.push({
        "field_name": field_name,
        "wire_name": f.name,
        "type": type_ref_to_string(f.type_),
        "optional": f.optional,
      })
      if field_name != f.name {
        rename_entries.push((field_name, f.name))
      }
    }
    let has_renames = rename_entries.length() > 0
    let field_renames_json : Array[Json] = Array::new()
    for j in 0..<rename_entries.length() {
      let entry = rename_entries[j]
      field_renames_json.push({
        "field_name": entry.0,
        "wire_name": entry.1,
        "is_last": j == rename_entries.length() - 1,
      })
    }
    {
      "name": m.name,
      "struct_name": @case.pascal_case(m.name),
      "fields": fields_json,
      "field_renames": field_renames_json,
      "has_renames": has_renames,
      "derive_fromjson": decode_models.contains(m.name),
    }
  })
  buf.write_string(@mustache.parse(model_template, { "models": models_json }))
  buf.to_string()
}

///|
let router_template : String =
  #|///|
  #|/// 路由匹配结果。
  #|#warnings("-unused_constructor")
  #|pub enum RouteMatch {
  #|  /// 已命中并写入响应（或已开始 SSE）。
  #|  Handled
  #|  /// 路径完全不匹配。
  #|  NotMatched
  #|  /// 路径匹配但 method 不被支持（可用于返回 405）。
  #|  MethodNotAllowed
  #|}
  #|
  #|///|
  #|pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch
  #|
  #|pub fn[{{#clients}}H{{client_index}} : {{trait_name}}, {{/clients}}] create_router(
  #|  {{#clients}}{{handler_var}}~ : H{{client_index}},
  #|  {{/clients}}
  #|  group~ : @async.TaskGroup[Unit],
  #|) -> Router {
  #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) -> RouteMatch {
  #|    let full_path = req.path
  #|    let path = strip_request_query(full_path)
  #|    {{#clients}}
  #|      {{#methods}}
  #|    if req.meth == {{http_meth_token}} && match_path_template("{{{path_template}}}", path) {
  #|      {{#has_body}}let body_bytes = body_stream.read_all()
  #|      let body_str = body_bytes.text()
  #|      {{/has_body}}
  #|      {{^has_body}}ignore(body_stream)
  #|      {{/has_body}}
  #|      {{#params}}
  #|      {{#isBody}}{{#isString}}let {{var_name}} = body_str{{/isString}}{{^isString}}let {{var_name}} : {{type_str}} = try { @json.from_json(@json.parse(body_str)) } catch { _ => @json.from_json(null) }{{/isString}}{{/isBody}}
  #|      {{#isPath}}let {{var_name}} = get_path_param("{{{path_template}}}", path, "{{wire_name}}"){{/isPath}}
  #|      {{#isHeader}}let {{var_name}} = get_header(req.headers, "{{wire_name}}"){{/isHeader}}
  #|      {{#isQuery}}let {{var_name}} = get_query_param(full_path, "{{wire_name}}"){{/isQuery}}
  #|      {{^isBody}}{{^isPath}}{{^isHeader}}{{^isQuery}}let {{var_name}} = ""{{/isQuery}}{{/isHeader}}{{/isPath}}{{/isBody}}
  #|      {{/params}}
  #|      {{#is_sse}}let sse = EventStreamWriter::start(conn, {{status_code}}, "{{reason_phrase}}")
  #|      {{{handler_var}}}.{{handler_method}}(group~, {{#call_args}}{{expr}},{{/call_args}})
  #|      return RouteMatch::Handled
  #|      {{/is_sse}}
  #|      {{^is_sse}}{{#has_response_body}}let resp_body = {{{handler_var}}}.{{handler_method}}(group~, {{#call_args}}{{expr}},{{/call_args}})
  #|      let headers : Map[String, String] = { "content-type": "application/json" }
  #|      conn.send_response({{status_code}}, "{{reason_phrase}}", extra_headers=headers)
  #|      conn.write(resp_body.to_json().stringify())
  #|      conn.end_response()
  #|      return RouteMatch::Handled
  #|      {{/has_response_body}}
  #|      {{^has_response_body}}{{{handler_var}}}.{{handler_method}}(group~, {{#call_args}}{{expr}},{{/call_args}})
  #|      conn.send_response({{status_code}}, "{{reason_phrase}}")
  #|      conn.end_response()
  #|      return RouteMatch::Handled
  #|      {{/has_response_body}}{{/is_sse}}
  #|    }
  #|      {{/methods}}
  #|    {{/clients}}
  #|    // 未找到“method+path 完全匹配”的 handler。再判定是否是“path 匹配但 method 不支持”。
  #|    let mut path_matched = false
  #|    {{#clients}}
  #|      {{#methods}}
  #|    if match_path_template("{{{path_template}}}", path) { path_matched = true }
  #|      {{/methods}}
  #|    {{/clients}}
  #|    if path_matched { RouteMatch::MethodNotAllowed } else { RouteMatch::NotMatched }
  #|  }
  #|}
  #|
  #|///|
  #|/// 创建一个“带默认 fallback”的 dispatch（`async (...)->Unit`），便于直接挂到 http server。
  #|///
  #|/// - `Handled`：router 已写入响应
  #|/// - `MethodNotAllowed`：发送 405
  #|/// - `NotMatched`：发送 404
  #|pub fn create_dispatch(router : Router) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit {
  #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) {
  #|    let result = router(req, body_stream, conn)
  #|    match result {
  #|      RouteMatch::Handled => ()
  #|      RouteMatch::MethodNotAllowed => {
  #|        conn.send_response(405, "Method Not Allowed")
  #|        conn.end_response()
  #|      }
  #|      RouteMatch::NotMatched => {
  #|        conn.send_response(404, "Not Found")
  #|        conn.write("not found")
  #|        conn.end_response()
  #|      }
  #|    }
  #|  }
  #|}
  #|

///|
fn status_reason_phrase(code : Int) -> String {
  if code == 200 {
    "OK"
  } else if code == 201 {
    "Created"
  } else if code == 202 {
    "Accepted"
  } else if code == 204 {
    "No Content"
  } else if code == 400 {
    "Bad Request"
  } else if code == 401 {
    "Unauthorized"
  } else if code == 403 {
    "Forbidden"
  } else if code == 404 {
    "Not Found"
  } else if code == 405 {
    "Method Not Allowed"
  } else if code == 409 {
    "Conflict"
  } else if code == 500 {
    "Internal Server Error"
  } else {
    "OK"
  }
}

///|
test "emit_server_router" {
  let crate : @codemodel.Crate = {
    name: "test_crate",
    version: "0.1.0",
    clients: [
      @codemodel.Client::{
        name: "TestClient",
        methods: [
          @codemodel.Method::{
            name: "GetItem",
            http_method: "GET",
            path: "/items/{itemId}",
            status_code: 200,
            response_body: None,
            is_sse: false,
            parameters: [
              @codemodel.Parameter::{
                name: "itemId",
                location: "path",
                type_: @codemodel.TypeRef::String,
              },
            ],
          },
          @codemodel.Method::{
            name: "CreateItem",
            http_method: "POST",
            path: "/items",
            status_code: 200,
            response_body: None,
            is_sse: false,
            parameters: [
              @codemodel.Parameter::{
                name: "body",
                location: "body",
                type_: @codemodel.TypeRef::Model(@codemodel.Model::{
                  name: "Item",
                  fields: [
                    @codemodel.ModelField::{
                      name: "name",
                      type_: @codemodel.TypeRef::String,
                      optional: false,
                    },
                  ],
                }),
              },
            ],
          },
        ],
      },
    ],
  }
  let router_code = emit_server_router(crate)
  inspect(
    router_code,
    content=(
      #|
      #|///|
      #|/// Traits for operation handlers
      #|pub(open) trait TestClientHandler {
      #|  async get_item(Self, group~ : @async.TaskGroup[Unit], item_id : String) -> Unit
      #|  async create_item(Self, group~ : @async.TaskGroup[Unit], body : Item) -> Unit
      #|  
      #|}
      #|///|
      #|/// 路由匹配结果。
      #|#warnings("-unused_constructor")
      #|pub enum RouteMatch {
      #|  /// 已命中并写入响应（或已开始 SSE）。
      #|  Handled
      #|  /// 路径完全不匹配。
      #|  NotMatched
      #|  /// 路径匹配但 method 不被支持（可用于返回 405）。
      #|  MethodNotAllowed
      #|}
      #|
      #|///|
      #|pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch
      #|
      #|pub fn[H0 : TestClientHandler, ] create_router(
      #|  test_client_handler~ : H0,
      #|  
      #|  group~ : @async.TaskGroup[Unit],
      #|) -> Router {
      #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) -> RouteMatch {
      #|    let full_path = req.path
      #|    let path = strip_request_query(full_path)
      #|    
      #|      
      #|    if req.meth == @http.Get && match_path_template("/items/{itemId}", path) {
      #|      
      #|      ignore(body_stream)
      #|      
      #|      
      #|      
      #|      let p_1_item_id = get_path_param("/items/{itemId}", path, "itemId")
      #|      
      #|      
      #|      
      #|      
      #|      
      #|      
      #|      test_client_handler.get_item(group~, p_1_item_id,)
      #|      conn.send_response(200, "OK")
      #|      conn.end_response()
      #|      return RouteMatch::Handled
      #|      
      #|    }
      #|      
      #|    if req.meth == @http.Post && match_path_template("/items", path) {
      #|      let body_bytes = body_stream.read_all()
      #|      let body_str = body_bytes.text()
      #|      
      #|      
      #|      
      #|      let p_2_body : Item = try { @json.from_json(@json.parse(body_str)) } catch { _ => @json.from_json(null) }
      #|      
      #|      
      #|      
      #|      
      #|      
      #|      
      #|      
      #|      test_client_handler.create_item(group~, p_2_body,)
      #|      conn.send_response(200, "OK")
      #|      conn.end_response()
      #|      return RouteMatch::Handled
      #|      
      #|    }
      #|      
      #|    
      #|    // 未找到“method+path 完全匹配”的 handler。再判定是否是“path 匹配但 method 不支持”。
      #|    let mut path_matched = false
      #|    
      #|      
      #|    if match_path_template("/items/{itemId}", path) { path_matched = true }
      #|      
      #|    
      #|      
      #|    if match_path_template("/items", path) { path_matched = true }
      #|      
      #|    
      #|    if path_matched { RouteMatch::MethodNotAllowed } else { RouteMatch::NotMatched }
      #|  }
      #|}
      #|
      #|///|
      #|/// 创建一个“带默认 fallback”的 dispatch（`async (...)->Unit`），便于直接挂到 http server。
      #|///
      #|/// - `Handled`：router 已写入响应
      #|/// - `MethodNotAllowed`：发送 405
      #|/// - `NotMatched`：发送 404
      #|pub fn create_dispatch(router : Router) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit {
      #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) {
      #|    let result = router(req, body_stream, conn)
      #|    match result {
      #|      RouteMatch::Handled => ()
      #|      RouteMatch::MethodNotAllowed => {
      #|        conn.send_response(405, "Method Not Allowed")
      #|        conn.end_response()
      #|      }
      #|      RouteMatch::NotMatched => {
      #|        conn.send_response(404, "Not Found")
      #|        conn.write("not found")
      #|        conn.end_response()
      #|      }
      #|    }
      #|  }
      #|}
      #|
    ),
  )
}

///|
fn emit_server_router(crate : @codemodel.Crate) -> String raise {
  let buf = StringBuilder::new(size_hint=8192)
  // 1. Generate Handler Traits

  let clients_json = crate.clients.map(fn(client) -> Json {
    let methods = client.methods.map(fn(op) -> Json {
      let params = op.parameters.map(fn(p) -> Json {
        {
          "name": @case.snake_case(p.name),
          "type": type_ref_to_string(p.type_),
        }
      })
      let return_type = match op.response_body {
        Some(t) => type_ref_to_string(t)
        None => "Unit"
      }
      {
        "method_name": @case.snake_case(op.name),
        "return_type": if op.is_sse {
          "Unit"
        } else {
          return_type
        },
        "is_sse": op.is_sse,
        "params": params,
      }
    })
    {
      "trait_name": @case.pascal_case(client.name) + "Handler",
      "methods": methods,
    }
  })
  buf.write_string(
    @mustache.parse(handler_trait_template, { "clients": clients_json }),
  )
  // 2. Generate Router
  fn compact_alpha_digit_underscore(s : String) -> String {
    let n = s.length()
    let sb = StringBuilder::new(size_hint=n)
    let mut i = 0
    while i < n {
      let ch = s.code_unit_at(i)
      if ch == '_' && i > 0 && i + 1 < n {
        let prev = s.code_unit_at(i - 1)
        let next = s.code_unit_at(i + 1)
        let prev_is_lower = prev >= 'a' && prev <= 'z'
        let next_is_digit = next >= '0' && next <= '9'
        if prev_is_lower && next_is_digit {
          i += 1
          continue
        }
      }
      sb.write_char(ch.to_int().unsafe_to_char())
      i += 1
    }
    sb.to_string()
  }

  let clients = crate.clients
  let mut op_counter = 0
  let used_handler_vars : Array[String] = Array::new()
  let clients_ctx : Array[Json] = Array::new()
  for i in 0..<clients.length() {
    let client = clients[i]
    let handler_var = {
      let base = {
        let s = compact_alpha_digit_underscore(
          sanitize_identifier(@case.snake_case(client.name)),
        )
        if s == "" {
          "h\{i}"
        } else {
          "\{s}_handler"
        }
      }
      let mut candidate = base
      let mut suffix = 1
      while true {
        let mut exists = false
        for name in used_handler_vars {
          if name == candidate {
            exists = true
            break
          }
        }
        if !exists {
          break
        }
        candidate = "\{base}_\{suffix}"
        suffix += 1
      }
      used_handler_vars.push(candidate)
      candidate
    }
    let methods_arr : Array[Json] = Array::new()
    for op in client.methods {
      op_counter += 1
      let meth = server_meth_ctor(op.http_method)
      let normalized_tmpl = normalize_uri_template(op.path)
      let tmpl = normalized_tmpl
        .replace_all(old="\\", new="\\\\")
        .replace_all(old="\"", new="\\\"")

      // detect body presence
      let has_body = for param in op.parameters {
        if param.location == "body" {
          break true
        }
      } else {
        false
      }
      let params_arr = Array::new()
      let call_arg_exprs : Array[String] = Array::new()
      let param_count = op.parameters.length()
      for j in 0..<param_count {
        let param = op.parameters[j]
        let pname = sanitize_identifier(@case.snake_case(param.name))
        let var_name = "p_\{op_counter}_\{pname}"
        let type_str = type_ref_to_string(param.type_)
        let param_ctx : Json = {
          "name": @case.snake_case(param.name),
          "wire_name": param.name,
          "var_name": var_name,
          "location": param.location,
          "type_str": type_str,
          "isBody": param.location == "body",
          "isPath": param.location == "path",
          "isHeader": param.location == "header",
          "isQuery": param.location == "query",
          "isString": type_str == "String",
        }
        params_arr.push(param_ctx)
        call_arg_exprs.push(var_name)
      }
      let is_sse = op.is_sse
      let has_response_body = op.response_body is Some(_) && !is_sse
      if is_sse {
        call_arg_exprs.push("sse")
      }
      let call_args : Array[Json] = {
        let args : Array[Json] = Array::new()
        let n = call_arg_exprs.length()
        for k in 0..<n {
          let arg : Json = { "expr": call_arg_exprs[k] }
          args.push(arg)
        }
        args
      }
      methods_arr.push({
        "method_name": @case.snake_case(op.name),
        "handler_method": @case.snake_case(op.name),
        "http_meth_token": meth,
        "path_template": tmpl,
        "has_body": has_body,
        "status_code": op.status_code.to_double(),
        "reason_phrase": status_reason_phrase(op.status_code),
        "has_response_body": has_response_body,
        "is_sse": is_sse,
        "params": params_arr,
        "call_args": call_args,
      })
    }
    clients_ctx.push({
      "handler_var": handler_var,
      "trait_name": @case.pascal_case(sanitize_identifier(client.name)) +
      "Handler",
      "client_index": i.to_double(),
      "methods": methods_arr,
    })
  }
  buf.write_string(@mustache.parse(router_template, { "clients": clients_ctx }))
  buf.to_string()
}

///|
fn analyze_router_helper_needs(crate : @codemodel.Crate) -> (Bool, Bool, Bool) {
  let mut need_path_param = false
  let mut need_header = false
  let mut need_query = false
  for client in crate.clients {
    for op in client.methods {
      for p in op.parameters {
        if p.location == "path" {
          need_path_param = true
        } else if p.location == "header" {
          need_header = true
        } else if p.location == "query" {
          need_query = true
        }
      }
    }
  }
  (need_path_param, need_header, need_query)
}

///|
fn emit_server_router_helpers(crate : @codemodel.Crate) -> String {
  let buf = StringBuilder::new(size_hint=2048)
  let (need_path_param, need_header, need_query) = analyze_router_helper_needs(
    crate,
  )
  buf.write_string(strip_request_query_code)
  buf.write_string(match_path_template_code)
  if need_path_param {
    buf.write_string(get_path_param_code)
  }
  if need_header {
    buf.write_string(get_header_code)
  }
  if need_query {
    buf.write_string(get_query_param_code)
  }
  buf.to_string()
}

///|
fn collect_decode_models_from_crate(
  crate : @codemodel.Crate,
) -> Map[String, @codemodel.Model] raise {
  let models = Map::new()
  fn collect_decode_models(type_ : @codemodel.TypeRef) -> Unit raise {
    match type_ {
      Union(u) =>
        fail(
          "Not supported: request-side untagged union \{u.name} in server code generation",
        )
      Model(m) =>
        if !models.contains(m.name) {
          models.set(m.name, m)
          for field in m.fields {
            collect_decode_models(field.type_)
          }
        }
      Array(t) => collect_decode_models(t)
      Record(t) => collect_decode_models(t)
      Nullable(t) => collect_decode_models(t)
      _ => ()
    }
  }

  for client in crate.clients {
    for op in client.methods {
      for param in op.parameters {
        collect_decode_models(param.type_)
      }
    }
  }
  models
}

///|
fn collect_encode_types_from_crate(
  crate : @codemodel.Crate,
) -> (Map[String, @codemodel.Model], Map[String, @codemodel.Union]) {
  let models = Map::new()
  let unions = Map::new()
  for client in crate.clients {
    for op in client.methods {
      match op.response_body {
        Some(t) => collect_encode_types(t, models, unions)
        None => ()
      }
    }
  }
  (models, unions)
}

///|
fn collect_encode_types(
  type_ : @codemodel.TypeRef,
  models : Map[String, @codemodel.Model],
  unions : Map[String, @codemodel.Union],
) -> Unit {
  match type_ {
    Model(m) =>
      if !models.contains(m.name) {
        models.set(m.name, m)
        for field in m.fields {
          collect_encode_types(field.type_, models, unions)
        }
      }
    Union(u) =>
      if !unions.contains(u.name) {
        unions.set(u.name, u)
        for v in u.variants {
          collect_encode_types(v.type_, models, unions)
        }
      }
    Array(t) => collect_encode_types(t, models, unions)
    Record(t) => collect_encode_types(t, models, unions)
    Nullable(t) => collect_encode_types(t, models, unions)
    _ => ()
  }
}

///|
fn server_meth_ctor(http_method : String) -> String {
  match http_method.to_upper() {
    "GET" => "@http.Get"
    "HEAD" => "@http.Head"
    "POST" => "@http.Post"
    "PUT" => "@http.Put"
    "DELETE" => "@http.Delete"
    "PATCH" => "@http.Patch"
    "OPTIONS" => "@http.Options"
    "TRACE" => "@http.Trace"
    "CONNECT" => "@http.Connect"
    _ => "@http.Get"
  }
}

///|
fn normalize_uri_template(template : String) -> String {
  let p1 = template.split("{?").to_array()
  let s = if p1.length() == 0 { template } else { p1[0].to_string() }
  let p2 = s.split("?").to_array()
  if p2.length() == 0 {
    s
  } else {
    p2[0].to_string()
  }
}
