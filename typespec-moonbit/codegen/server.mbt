/// Server 代码生成模块：生成基于 `moonbitlang/async/http` 的 server 包。

///|
/// 生成 server 包的文件列表。
pub fn emit_server_files(crate : @codemodel.Crate) -> Array[OutputFile] raise {
  let files = Array::new(capacity=3)
  files.push(OutputFile::new("moon.pkg.json", emit_server_moon_pkg_json()))
  files.push(OutputFile::new("README.mbt.md", emit_server_readme(crate)))
  files.push(OutputFile::new("router.mbt", emit_server_router(crate)))
  files
}

///|
fn emit_server_moon_pkg_json() -> String {
  (
    #|{
    #|  "import": [
    #|    "moonbitlang/async/http",
    #|    "moonbitlang/async/io",
    #|    "moonbitlang/core/json"
    #|  ]
    #|}
  )
}

///|
fn emit_server_readme(crate : @codemodel.Crate) -> String {
  (
    $|# \{crate.name}
    $|
    $|Generated by typespec-moonbit.
    $|
    $|This MoonBit package can be imported by other packages to start a server.
  )
}

///|
let model_template : String =
  #|{{#models}}
  #|///|
  #|/// Model {{name}}
  #|pub(all) struct {{struct_name}} {
  #|{{#fields}}
  #|  {{name}} : {{type}}{{#optional}}?{{/optional}}
  #|{{/fields}}
  #|} derive(Show, Default, {{#derive_tojson}}ToJson, {{/derive_tojson}}@json.FromJson(rename_fields="camelCase"))
  #|
  #|{{^derive_tojson}}
  #|pub impl ToJson for {{struct_name}} with to_json(self : {{struct_name}}) -> Json {
  #|  let m : Map[String, Json] = Map::new()
  #|  {{#fields}}
  #|  {{^optional}}m.set("{{json_name}}", self.{{name}}.to_json())
  #|  {{/optional}}
  #|  {{#optional}}match self.{{name}} { Some(v) => m.set("{{json_name}}", v.to_json()) ; None => () }
  #|  {{/optional}}
  #|  {{/fields}}
  #|  Json::object(m)
  #|}
  #|{{/derive_tojson}}
  #|
  #|{{/models}}

///|
let handler_trait_template : String =
  #|{{#clients}}
  #|///|
  #|/// Traits for operation handlers
  #|pub(open) trait {{trait_name}} {
  #|  {{#methods}}async {{method_name}}(Self{{#params}}, {{name}} : {{type}}{{/params}}) -> {{return_type}}
  #|  {{/methods}}
  #|}
  #|{{/clients}}

///|
let nullable_support_code : String =
  #|///|
  #|/// Nullable helper used for `T | null`.
  #|pub(all) struct Nullable[T] {
  #|  value : T?
  #|} derive(Show, Default)
  #|
  #|///|
  #|pub fn Nullable::some[T](v : T) -> Nullable[T] {
  #|  { value: Some(v) }
  #|}
  #|
  #|///|
  #|pub fn Nullable::none[T]() -> Nullable[T] {
  #|  { value: None }
  #|}
  #|
  #|///|
  #|pub impl[T : ToJson] ToJson for Nullable[T] with to_json(self : Nullable[T]) -> Json {
  #|  match self.value {
  #|    Some(v) => v.to_json()
  #|    None => Json::null()
  #|  }
  #|}
  #|
  #|///|
  #|pub impl[T : @json.FromJson] @json.FromJson for Nullable[T] with from_json(
  #|  j : Json,
  #|  path : @json.JsonPath,
  #|) -> Nullable[T] raise @json.JsonDecodeError {
  #|  if j == Json::null() {
  #|    { value: None }
  #|  } else {
  #|    { value: Some(@json.from_json(j, path=path)) }
  #|  }
  #|}
  #|

///|
let router_template : String =
  #|pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit
  #|
  #|pub fn[{{#clients}}H{{client_index}} : {{trait_name}}{{^is_last}}, {{/is_last}}{{/clients}}] create_router({{#clients}}{{handler_var}} : H{{client_index}}{{^is_last}}, {{/is_last}}{{/clients}}) -> Router {
  #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) {
  #|    let path = strip_request_query(req.path)
  #|    if false { () }
  #|    {{#clients}}
  #|      {{#methods}}
  #|    else if req.meth == {{http_meth_token}} && match_path_template("{{{path_template}}}", path) {
  #|      {{#has_body}}let body_bytes = body_stream.read_all()
  #|      let body_str = body_bytes.text()
  #|      {{/has_body}}
  #|      {{^has_body}}ignore(body_stream)
  #|      {{/has_body}}
  #|      {{#params}}
  #|      {{#isBody}}{{#isString}}let {{var_name}} = body_str{{/isString}}{{^isString}}let {{var_name}} : {{type_str}} = try { @json.from_json(@json.parse(body_str)) } catch { _ => @json.from_json(null) }{{/isString}}{{/isBody}}
  #|      {{^isBody}}let {{var_name}} = ""{{/isBody}}
  #|      {{/params}}
  #|      {{#has_response_body}}let resp_body = {{{handler_var}}}.{{handler_method}}({{#params}}{{var_name}}{{^is_last}}, {{/is_last}}{{/params}})
  #|      let headers : Map[String, String] = { "content-type": "application/json" }
  #|      conn.send_response({{status_code}}, "{{reason_phrase}}", extra_headers=headers)
  #|      conn.write(resp_body.to_json().stringify())
  #|      conn.end_response()
  #|      {{/has_response_body}}
  #|      {{^has_response_body}}{{{handler_var}}}.{{handler_method}}({{#params}}{{var_name}}{{^is_last}}, {{/is_last}}{{/params}})
  #|      conn.send_response({{status_code}}, "{{reason_phrase}}")
  #|      conn.end_response()
  #|      {{/has_response_body}}
  #|    }
  #|      {{/methods}}
  #|    {{/clients}}
  #|    else {
  #|      conn.send_response(404, "NotFound")
  #|      conn.write("not found")
  #|      conn.end_response()
  #|    }
  #|  }
  #|}
  #|

///|
fn status_reason_phrase(code : Int) -> String {
  if code == 200 {
    "OK"
  } else if code == 201 {
    "Created"
  } else if code == 202 {
    "Accepted"
  } else if code == 204 {
    "No Content"
  } else if code == 400 {
    "Bad Request"
  } else if code == 401 {
    "Unauthorized"
  } else if code == 403 {
    "Forbidden"
  } else if code == 404 {
    "Not Found"
  } else if code == 409 {
    "Conflict"
  } else if code == 500 {
    "Internal Server Error"
  } else {
    "OK"
  }
}

///|
fn emit_create_router(crate : @codemodel.Crate) -> String raise {
  let clients = crate.clients
  let mut op_counter = 0
  let clients_ctx : Array[Json] = Array::new()
  for i in 0..<clients.length() {
    let client = clients[i]
    let methods_arr : Array[Json] = Array::new()
    for op in client.methods {
      op_counter += 1
      let meth = server_meth_ctor(op.http_method)
      let normalized_tmpl = normalize_uri_template(op.path)
      let tmpl = normalized_tmpl
        .replace_all(old="\\", new="\\\\")
        .replace_all(old="\"", new="\\\"")

      // detect body presence
      let has_body = for param in op.parameters {
        if param.location == "body" {
          break true
        }
      } else {
        false
      }
      let params_arr = Array::new()
      let param_count = op.parameters.length()
      for j in 0..<param_count {
        let param = op.parameters[j]
        let pname = sanitize_identifier(@case.snake_case(param.name))
        let var_name = "p_\{op_counter}_\{pname}"
        let type_str = type_ref_to_string(param.type_)
        let param_ctx : Json = {
          "name": @case.snake_case(param.name),
          "var_name": var_name,
          "location": param.location,
          "type_str": type_str,
          "isBody": param.location == "body",
          "isString": type_str == "String",
          "is_last": j == param_count - 1,
        }
        params_arr.push(param_ctx)
      }
      let has_response_body = op.response_body is Some(_)
      let return_type = match op.response_body {
        Some(t) => type_ref_to_string(t)
        None => "Unit"
      }
      methods_arr.push({
        "method_name": @case.snake_case(op.name),
        "handler_method": @case.snake_case(op.name),
        "http_meth_token": meth,
        "path_template": tmpl,
        "has_body": has_body,
        "status_code": op.status_code.to_double(),
        "reason_phrase": status_reason_phrase(op.status_code),
        "has_response_body": has_response_body,
        "return_type": return_type,
        "params": params_arr,
      })
    }
    clients_ctx.push({
      "handler_var": "h\{i}",
      "trait_name": @case.pascal_case(sanitize_identifier(client.name)) +
      "Handler",
      "client_index": i.to_double(),
      "is_last": i == clients.length() - 1,
      "methods": methods_arr,
    })
  }
  @mustache.parse(router_template, { "clients": clients_ctx })
}

///|
test "emit_server_router" {
  let router_code = emit_server_router({
    name: "test_crate",
    version: "0.1.0",
    clients: [
      @codemodel.Client::{
        name: "TestClient",
        methods: [
          @codemodel.Method::{
            name: "GetItem",
            http_method: "GET",
            path: "/items/{itemId}",
            status_code: 200,
            response_body: None,
            parameters: [
              @codemodel.Parameter::{
                name: "itemId",
                location: "path",
                type_: @codemodel.TypeRef::String,
              },
            ],
          },
          @codemodel.Method::{
            name: "CreateItem",
            http_method: "POST",
            path: "/items",
            status_code: 200,
            response_body: None,
            parameters: [
              @codemodel.Parameter::{
                name: "body",
                location: "body",
                type_: @codemodel.TypeRef::Model(@codemodel.Model::{
                  name: "Item",
                  fields: [
                    @codemodel.ModelField::{
                      name: "name",
                      type_: @codemodel.TypeRef::String,
                      optional: false,
                    },
                  ],
                }),
              },
            ],
          },
        ],
      },
    ],
  })
  inspect(
    router_code,
    content=(
      #|///|
      #|/// Nullable helper used for `T | null`.
      #|pub(all) struct Nullable[T] {
      #|  value : T?
      #|} derive(Show, Default)
      #|
      #|///|
      #|pub fn Nullable::some[T](v : T) -> Nullable[T] {
      #|  { value: Some(v) }
      #|}
      #|
      #|///|
      #|pub fn Nullable::none[T]() -> Nullable[T] {
      #|  { value: None }
      #|}
      #|
      #|///|
      #|pub impl[T : ToJson] ToJson for Nullable[T] with to_json(self : Nullable[T]) -> Json {
      #|  match self.value {
      #|    Some(v) => v.to_json()
      #|    None => Json::null()
      #|  }
      #|}
      #|
      #|///|
      #|pub impl[T : @json.FromJson] @json.FromJson for Nullable[T] with from_json(
      #|  j : Json,
      #|  path : @json.JsonPath,
      #|) -> Nullable[T] raise @json.JsonDecodeError {
      #|  if j == Json::null() {
      #|    { value: None }
      #|  } else {
      #|    { value: Some(@json.from_json(j, path=path)) }
      #|  }
      #|}
      #|
      #|///|
      #|/// Model Item
      #|pub(all) struct Item {
      #|
      #|  name : String
      #|
      #|} derive(Show, Default, ToJson, @json.FromJson(rename_fields="camelCase"))
      #|
      #|
      #|
      #|
      #|///|
      #|/// Traits for operation handlers
      #|pub(open) trait TestClientHandler {
      #|  async get_item(Self, item_id : String) -> Unit
      #|  async create_item(Self, body : Item) -> Unit
      #|  
      #|}
      #|pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit
      #|
      #|pub fn[H0 : TestClientHandler] create_router(h0 : H0) -> Router {
      #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) {
      #|    let path = strip_request_query(req.path)
      #|    if false { () }
      #|    
      #|      
      #|    else if req.meth == @http.Get && match_path_template("/items/{itemId}", path) {
      #|      
      #|      ignore(body_stream)
      #|      
      #|      
      #|      
      #|      let p_1_item_id = ""
      #|      
      #|      
      #|      h0.get_item(p_1_item_id)
      #|      conn.send_response(200, "OK")
      #|      conn.end_response()
      #|      
      #|    }
      #|      
      #|    else if req.meth == @http.Post && match_path_template("/items", path) {
      #|      let body_bytes = body_stream.read_all()
      #|      let body_str = body_bytes.text()
      #|      
      #|      
      #|      
      #|      let p_2_body : Item = try { @json.from_json(@json.parse(body_str)) } catch { _ => @json.from_json(null) }
      #|      
      #|      
      #|      
      #|      h0.create_item(p_2_body)
      #|      conn.send_response(200, "OK")
      #|      conn.end_response()
      #|      
      #|    }
      #|      
      #|    
      #|    else {
      #|      conn.send_response(404, "NotFound")
      #|      conn.write("not found")
      #|      conn.end_response()
      #|    }
      #|  }
      #|}
      #|///|
      #|fn strip_request_query(path : String) -> String {
      #|  let parts = path.split("?").to_array()
      #|  if parts.length() == 0 { path } else { parts[0].to_string() }
      #|}
      #|///|
      #|fn match_path_template(template : String, path : String) -> Bool {
      #|  let t = template.trim(char_set="/")
      #|  let p = path.trim(char_set="/")
      #|  let t_segs = if t == "" { [] } else { t.split("/").to_array() }
      #|  let p_segs = if p == "" { [] } else { p.split("/").to_array() }
      #|  if t_segs.length() != p_segs.length() { return false }
      #|  for i in 0..<t_segs.length() {
      #|    let ts = t_segs[i].to_string()
      #|    let ps = p_segs[i].to_string()
      #|    if ts.length() >= 2 && ts.has_prefix("{") && ts.has_suffix("}") {
      #|      if ps == "" { return false }
      #|    } else if ts != ps { return false }
      #|  }
      #|  true
      #|}
      #|
    ),
  )
}

///|
fn emit_server_router(crate : @codemodel.Crate) -> String raise {
  let buf = StringBuilder::new(size_hint=8192)

  // 1. Collect Models
  let models = Map::new()
  for client in crate.clients {
    for op in client.methods {
      for param in op.parameters {
        collect_models(param.type_, models)
      }
      match op.response_body {
        Some(t) => collect_models(t, models)
        None => ()
      }
    }
  }

  // 2. Nullable helper (for `T | null`)
  buf.write_string(nullable_support_code)

  // 3. Generate Model Structs
  let model_list = models.to_array()
  model_list.sort_by_key(fn(m) { m.0 })
  let models_json = model_list.map(fn(item) -> Json {
    let m = item.1
    let mut has_optional_fields = false
    for f in m.fields {
      if f.optional {
        has_optional_fields = true
      }
    }
    let fields = m.fields.map(fn(f) -> Json {
      {
        "name": @case.snake_case(f.name),
        "json_name": @case.camel_case(f.name),
        "type": type_ref_to_string(f.type_),
        "optional": f.optional,
      }
    })
    {
      "name": m.name,
      "struct_name": @case.pascal_case(m.name),
      "fields": fields,
      "derive_tojson": !has_optional_fields,
    }
  })
  buf.write_string(@mustache.parse(model_template, { "models": models_json }))

  // 4. Generate Handler Traits

  let clients_json = crate.clients.map(fn(client) -> Json {
    let methods = client.methods.map(fn(op) -> Json {
      let params = op.parameters.map(fn(p) -> Json {
        {
          "name": @case.snake_case(p.name),
          "type": type_ref_to_string(p.type_),
        }
      })
      let return_type = match op.response_body {
        Some(t) => type_ref_to_string(t)
        None => "Unit"
      }
      {
        "method_name": @case.snake_case(op.name),
        "return_type": return_type,
        "params": params,
      }
    })
    {
      "trait_name": @case.pascal_case(client.name) + "Handler",
      "methods": methods,
    }
  })
  buf.write_string(
    @mustache.parse(handler_trait_template, { "clients": clients_json }),
  )
  buf.write_string(emit_create_router(crate))
  buf.write_string(strip_request_query_code)
  buf.write_string(match_path_template_code)
  buf.to_string()
}

///|
let strip_request_query_code =
  #|///|
  #|fn strip_request_query(path : String) -> String {
  #|  let parts = path.split("?").to_array()
  #|  if parts.length() == 0 { path } else { parts[0].to_string() }
  #|}
  #|

///|
let match_path_template_code =
  #|///|
  #|fn match_path_template(template : String, path : String) -> Bool {
  #|  let t = template.trim(char_set="/")
  #|  let p = path.trim(char_set="/")
  #|  let t_segs = if t == "" { [] } else { t.split("/").to_array() }
  #|  let p_segs = if p == "" { [] } else { p.split("/").to_array() }
  #|  if t_segs.length() != p_segs.length() { return false }
  #|  for i in 0..<t_segs.length() {
  #|    let ts = t_segs[i].to_string()
  #|    let ps = p_segs[i].to_string()
  #|    if ts.length() >= 2 && ts.has_prefix("{") && ts.has_suffix("}") {
  #|      if ps == "" { return false }
  #|    } else if ts != ps { return false }
  #|  }
  #|  true
  #|}
  #|

///|
fn collect_models(
  type_ : @codemodel.TypeRef,
  models : Map[String, @codemodel.Model],
) -> Unit {
  match type_ {
    Model(m) =>
      if !models.contains(m.name) {
        models.set(m.name, m)
        for field in m.fields {
          collect_models(field.type_, models)
        }
      }
    Array(t) => collect_models(t, models)
    Record(t) => collect_models(t, models)
    Nullable(t) => collect_models(t, models)
    _ => ()
  }
}

///|
fn server_meth_ctor(http_method : String) -> String {
  match http_method.to_upper() {
    "GET" => "@http.Get"
    "HEAD" => "@http.Head"
    "POST" => "@http.Post"
    "PUT" => "@http.Put"
    "DELETE" => "@http.Delete"
    "PATCH" => "@http.Patch"
    "OPTIONS" => "@http.Options"
    "TRACE" => "@http.Trace"
    "CONNECT" => "@http.Connect"
    _ => "@http.Get"
  }
}

///|
fn normalize_uri_template(template : String) -> String {
  let p1 = template.split("{?").to_array()
  let s = if p1.length() == 0 { template } else { p1[0].to_string() }
  let p2 = s.split("?").to_array()
  if p2.length() == 0 {
    s
  } else {
    p2[0].to_string()
  }
}
