// Generated using `moon info`, DON'T EDIT IT
package "kkkiio/typespec-tests/server/generated/parameters/spread"

import {
  "moonbitlang/async",
  "moonbitlang/async/http",
  "moonbitlang/async/io",
  "moonbitlang/core/json",
}

// Values
pub fn create_dispatch(async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit

pub fn[H0 : ModelHandler, H1 : AliasHandler] create_router(model_handler~ : H0, alias_handler~ : H1, group~ : @async.TaskGroup[Unit]) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch

pub fn match_route(@http.RequestMethod, String) -> MatchRouteResult

// Errors

// Types and methods
pub(all) struct BodyParameter {
  name : String
}
pub impl Show for BodyParameter
pub impl ToJson for BodyParameter
pub impl @json.FromJson for BodyParameter

pub(all) struct BodyParameter5 {
  name : String
}
pub impl Show for BodyParameter5
pub impl ToJson for BodyParameter5
pub impl @json.FromJson for BodyParameter5

pub(all) enum MatchRouteResult {
  NotMatched
  MethodNotAllowed
  Matched(RouteId)
}

pub(all) struct Model0 {
  name : String
}
pub impl Show for Model0
pub impl ToJson for Model0
pub impl @json.FromJson for Model0

pub(all) struct Model1 {
  name : String
}
pub impl Show for Model1
pub impl ToJson for Model1
pub impl @json.FromJson for Model1

pub(all) struct Model2 {
  name : String
}
pub impl Show for Model2
pub impl ToJson for Model2
pub impl @json.FromJson for Model2

pub(all) struct Model3 {
  required_string : String
  optional_int : Int?
  required_int_list : Array[Int]
  optional_string_list : Array[String]?
}
pub impl Show for Model3
pub impl ToJson for Model3
pub impl @json.FromJson for Model3

pub(all) struct Model4 {
  name : String
  age : Int
}
pub impl Show for Model4
pub impl ToJson for Model4
pub impl @json.FromJson for Model4

pub(all) struct Model6 {
  prop : String
}
pub impl Show for Model6
pub impl ToJson for Model6
pub impl @json.FromJson for Model6

pub(all) enum RouteId {
  ModelSpreadAsRequestBody
  ModelSpreadCompositeRequest(Array[String])
  ModelSpreadCompositeRequestMix(Array[String])
  ModelSpreadCompositeRequestOnlyWithBody
  ModelSpreadCompositeRequestWithoutBody(Array[String])
  AliasSpreadAsRequestBody
  AliasSpreadAsRequestParameter(Array[String])
  AliasSpreadWithMultipleParameters(Array[String])
  AliasSpreadParameterWithInnerAlias(Array[String])
  AliasSpreadParameterWithInnerModel(Array[String])
}

pub(all) enum RouteMatch {
  Handled
  NotMatched
  MethodNotAllowed
}

// Type aliases
pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch

// Traits
pub(open) trait AliasHandler {
  async spread_as_request_body(Self, group~ : @async.TaskGroup[Unit], Model0) -> Unit
  async spread_as_request_parameter(Self, group~ : @async.TaskGroup[Unit], String, String, Model2) -> Unit
  async spread_with_multiple_parameters(Self, group~ : @async.TaskGroup[Unit], String, String, Model3) -> Unit
  async spread_parameter_with_inner_alias(Self, group~ : @async.TaskGroup[Unit], String, String, Model4) -> Unit
  async spread_parameter_with_inner_model(Self, group~ : @async.TaskGroup[Unit], String, String, Model1) -> Unit
}

pub(open) trait ModelHandler {
  async spread_as_request_body(Self, group~ : @async.TaskGroup[Unit], BodyParameter5) -> Unit
  async spread_composite_request(Self, group~ : @async.TaskGroup[Unit], String, String, BodyParameter) -> Unit
  async spread_composite_request_mix(Self, group~ : @async.TaskGroup[Unit], String, String, Model6) -> Unit
  async spread_composite_request_only_with_body(Self, group~ : @async.TaskGroup[Unit], BodyParameter) -> Unit
  async spread_composite_request_without_body(Self, group~ : @async.TaskGroup[Unit], String, String) -> Unit
}

