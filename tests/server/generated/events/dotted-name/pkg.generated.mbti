// Generated using `moon info`, DON'T EDIT IT
package "kkkiio/typespec-tests/server/generated/events/dotted-name"

import {
  "moonbitlang/async",
  "moonbitlang/async/aqueue",
  "moonbitlang/async/http",
  "moonbitlang/async/io",
  "moonbitlang/core/json",
}

// Values
pub fn create_dispatch(async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit

pub fn[H0 : DottedNameHandler] create_router(dotted_name_handler~ : H0, group~ : @async.TaskGroup[Unit]) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch

pub fn match_route(@http.RequestMethod, String) -> MatchRouteResult

// Errors

// Types and methods
pub(all) enum DottedNameWatchTasksResult {
  Stream(TaskEventsStream)
  Status400(Model0)
}

pub(all) enum MatchRouteResult {
  NotMatched
  MethodNotAllowed
  Matched(RouteId)
}

pub(all) struct Model0 {
  error : Json
}
pub impl Show for Model0
pub impl ToJson for Model0
pub impl @json.FromJson for Model0

pub(all) enum RouteId {
  DottedNameWatchTasks
}

pub(all) enum RouteMatch {
  Handled
  NotMatched
  MethodNotAllowed
}

pub(all) enum TaskEvents {
  MariaQueuedMessagesSynchronized(Json)
  Maria(Json)
}
pub impl Show for TaskEvents

pub(all) struct TaskEventsStream {
  queue : @aqueue.Queue[TaskEvents]
}
pub fn TaskEventsStream::close(Self) -> Unit
pub fn TaskEventsStream::new() -> Self
pub async fn TaskEventsStream::write_event(Self, TaskEvents) -> Unit

// Type aliases
pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch

// Traits
pub(open) trait DottedNameHandler {
  async watch_tasks(Self, group~ : @async.TaskGroup[Unit], String) -> DottedNameWatchTasksResult
}

