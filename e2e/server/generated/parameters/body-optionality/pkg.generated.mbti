// Generated using `moon info`, DON'T EDIT IT
package "kkkiio/typespec-moonbit-tests/server/generated/parameters/body-optionality"

import {
  "kkkiio/typespec-moonbit-server-runtime/runtime",
  "moonbitlang/async",
  "moonbitlang/async/http",
  "moonbitlang/async/io",
  "moonbitlang/core/json",
}

// Values
pub fn create_dispatch(async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit

pub fn[H0 : BodyOptionalityHandler, H1 : OptionalExplicitHandler] create_router(body_optionality_handler~ : H0, optional_explicit_handler~ : H1, group~ : @async.TaskGroup[Unit]) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch

pub fn match_route(@http.RequestMethod, String) -> MatchRouteResult

// Errors

// Types and methods
pub(all) struct BodyModel {
  name : String
}
pub impl Default for BodyModel
pub impl Show for BodyModel
pub impl ToJson for BodyModel
pub impl @json.FromJson for BodyModel

pub(all) struct BodyModel0 {
  name : String
}
pub impl Default for BodyModel0
pub impl Show for BodyModel0
pub impl ToJson for BodyModel0
pub impl @json.FromJson for BodyModel0

pub enum MatchRouteResult {
  NotMatched
  MethodNotAllowed
  Matched(RouteId)
}

pub enum RouteId {
  BodyOptionalityRequiredExplicit
  BodyOptionalityRequiredImplicit
  OptionalExplicitSet
  OptionalExplicitOmit
}

pub enum RouteMatch {
  Handled
  NotMatched
  MethodNotAllowed
}

// Type aliases
pub using @runtime {type Nullable}

pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch

// Traits
pub(open) trait BodyOptionalityHandler {
  async required_explicit(Self, group~ : @async.TaskGroup[Unit], BodyModel) -> Unit
  async required_implicit(Self, group~ : @async.TaskGroup[Unit], BodyModel0) -> Unit
}

pub(open) trait OptionalExplicitHandler {
  async set(Self, group~ : @async.TaskGroup[Unit], BodyModel) -> Unit
  async omit(Self, group~ : @async.TaskGroup[Unit], BodyModel) -> Unit
}

