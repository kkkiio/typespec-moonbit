// Generated using `moon info`, DON'T EDIT IT
package "kkkiio/typespec-moonbit-tests/server/generated/type/dictionary"

import {
  "moonbitlang/async",
  "moonbitlang/async/http",
  "moonbitlang/async/io",
  "moonbitlang/core/json",
}

// Values
pub fn create_dispatch(async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit

pub fn[H0 : Int32ValueHandler, H1 : Int64ValueHandler, H2 : ModelValueHandler, H3 : StringValueHandler, H4 : BooleanValueHandler, H5 : Float32ValueHandler, H6 : UnknownValueHandler, H7 : DatetimeValueHandler, H8 : DurationValueHandler, H9 : NullableFloatValueHandler, H10 : RecursiveModelValueHandler] create_router(int32_value_handler~ : H0, int64_value_handler~ : H1, model_value_handler~ : H2, string_value_handler~ : H3, boolean_value_handler~ : H4, float32_value_handler~ : H5, unknown_value_handler~ : H6, datetime_value_handler~ : H7, duration_value_handler~ : H8, nullable_float_value_handler~ : H9, recursive_model_value_handler~ : H10, group~ : @async.TaskGroup[Unit]) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch

// Errors

// Types and methods
pub(all) struct InnerModel {
  property : String
  children : Map[String, InnerModel]?
}
pub impl Default for InnerModel
pub impl Show for InnerModel
pub impl ToJson for InnerModel
pub impl @json.FromJson for InnerModel

pub(all) struct Nullable[T](T?)
#deprecated
pub fn[T] Nullable::inner(Self[T]) -> T?
pub impl[T : Compare] Compare for Nullable[T]
pub impl[T : Default] Default for Nullable[T]
pub impl[T : Eq] Eq for Nullable[T]
pub impl[T : Show] Show for Nullable[T]
pub impl[T : ToJson] ToJson for Nullable[T]
pub impl[T : @json.FromJson] @json.FromJson for Nullable[T]

pub enum RouteMatch {
  Handled
  NotMatched
  MethodNotAllowed
}

// Type aliases
pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch

// Traits
pub(open) trait BooleanValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, Bool]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, Bool]) -> Unit
}

pub(open) trait DatetimeValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, String]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, String]) -> Unit
}

pub(open) trait DurationValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, String]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, String]) -> Unit
}

pub(open) trait Float32ValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, Double]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, Double]) -> Unit
}

pub(open) trait Int32ValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, Int]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, Int]) -> Unit
}

pub(open) trait Int64ValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, Int64]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, Int64]) -> Unit
}

pub(open) trait ModelValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, InnerModel]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, InnerModel]) -> Unit
}

pub(open) trait NullableFloatValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, Nullable[Double]]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, Nullable[Double]]) -> Unit
}

pub(open) trait RecursiveModelValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, InnerModel]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, InnerModel]) -> Unit
}

pub(open) trait StringValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, String]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, String]) -> Unit
}

pub(open) trait UnknownValueHandler {
  async get(Self, group~ : @async.TaskGroup[Unit]) -> Map[String, Json]
  async put(Self, group~ : @async.TaskGroup[Unit], Map[String, Json]) -> Unit
}

