/// Server 代码生成实现（放在 server emitter package 内，避免 codegen 包承担 server 生成逻辑）。

///|
fn type_ref_to_string(type_ : @codemodel.TypeRef) -> String {
  match type_ {
    String => "String"
    Int32 => "Int"
    Int64 => "Int64"
    Float64 => "Double"
    Bool => "Bool"
    Json => "Json"
    Model(m) => @case.pascal_case(m.name)
    Union(u) => @case.pascal_case(u.name)
    Array(t) => "Array[\{type_ref_to_string(t)}]"
    Record(t) => "Map[String, \{type_ref_to_string(t)}]"
    Nullable(t) => "Nullable[\{type_ref_to_string(t)}]"
  }
}

///|
fn wln(sb : StringBuilder, s : String) -> Unit {
  sb.write_string(s)
  sb.write_char('\n')
}

///|
fn write_escaped_string_literal(sb : StringBuilder, s : String) -> Unit {
  // Escape `\` and `"` for MoonBit string literal.
  let n = s.length()
  let mut i = 0
  while i < n {
    let ch = s.code_unit_at(i)
    if ch == '\\' {
      sb.write_string("\\\\")
    } else if ch == '"' {
      sb.write_string("\\\"")
    } else {
      sb.write_char(ch.to_int().unsafe_to_char())
    }
    i += 1
  }
}

///|
pub fn emit_server_files(
  crate : @codemodel.Crate,
) -> Array[@codegen.OutputFile] raise {
  [
    @codegen.OutputFile::new("moon.pkg.json", emit_server_moon_pkg_json()),
    @codegen.OutputFile::new("README.mbt.md", emit_server_readme(crate)),
    @codegen.OutputFile::new("models.mbt", emit_server_models(crate)),
    @codegen.OutputFile::new("router.mbt", emit_server_router(crate)),
  ]
}

///|
fn emit_server_moon_pkg_json() -> String {
  (
    #|{
    #|  "import": [
    #|    "moonbitlang/core/json",
    #|    "moonbitlang/async",
    #|    "moonbitlang/async/http",
    #|    "moonbitlang/async/io",
    #|    "moonbitlang/async/aqueue",
    #|    "kkkiio/typespec-moonbit-server-runtime/runtime"
    #|  ]
    #|}
  )
}

///|
fn emit_server_readme(crate : @codemodel.Crate) -> String {
  (
    $|# \{crate.name}
    $|
    $|Generated by typespec-moonbit.
    $|
    $|This MoonBit package can be imported by other packages to start a server.
  )
}

///|
fn collect_sse_unions(
  crate : @codemodel.Crate,
) -> Map[String, @codemodel.Union] raise {
  let sse_unions = Map::new()
  for client in crate.clients {
    for op in client.methods {
      if !op.is_sse {
        continue
      }
      match op.sse_event_union {
        Some(u) => if !sse_unions.contains(u.name) { sse_unions.set(u.name, u) }
        None =>
          fail("sse operation \{client.name}.\{op.name} missing events union")
      }
    }
  }
  sse_unions
}

///|
fn sse_stream_name(u : @codemodel.Union) -> String {
  "\{@case.pascal_case(u.name)}Stream"
}

///|
fn sse_result_name(
  client : @codemodel.Client,
  op : @codemodel.Method,
) -> String {
  "\{@case.pascal_case(client.name)}\{@case.pascal_case(op.name)}Result"
}

///|
fn status_variant_name(code : Int) -> String {
  "Status\{code.to_string()}"
}

///|
fn write_sse_event_stream(sb : StringBuilder, u : @codemodel.Union) -> Unit {
  let enum_name = @case.pascal_case(u.name)
  let stream_name = sse_stream_name(u)
  sb.write_string(
    (
      $|///|
      $|/// SSE stream for \{enum_name}
      $|pub struct \{stream_name} {
      $|  queue : @async.Queue[\{enum_name}]
      $|}
      $|
      $|///|
      $|pub fn \{stream_name}::new() -> \{stream_name} {
      $|  \{stream_name}::{ queue: @async.Queue::new(kind=Blocking(0)) }
      $|}
      $|
      $|///|
      $|pub async fn \{stream_name}::write_event(self : \{stream_name}, event : \{enum_name}) -> Unit {
      $|  self.queue.put(event)
      $|}
      $|
      $|///|
      $|pub fn \{stream_name}::close(self : \{stream_name}) -> Unit {
      $|  self.queue.close()
      $|}
      $|
      $|///|
      $|async fn \{stream_name}::next(self : \{stream_name}) -> \{enum_name}? {
      $|  Some(self.queue.get()) catch {
      $|    @aqueue.QueueAlreadyClosed => None
      $|    err => raise err
      $|  }
      $|}
      $|
    ),
  )
}

///|
fn write_sse_result_enum(
  sb : StringBuilder,
  client : @codemodel.Client,
  op : @codemodel.Method,
  u : @codemodel.Union,
) -> Unit {
  let result_name = sse_result_name(client, op)
  let stream_name = sse_stream_name(u)
  sb.write_string(
    (
      $|///|
      $|pub(all) enum \{result_name} {
      $|  Stream(\{stream_name})
      $|
    ),
  )
  for err in op.sse_error_responses {
    let ctor = status_variant_name(err.status_code)
    match err.body {
      Some(body_type) => wln(sb, "  \{ctor}(\{type_ref_to_string(body_type)})")
      None => wln(sb, "  \{ctor}")
    }
  }
  sb.write_string(
    (
      #|}
      #|
    ),
  )
}

///|
fn status_reason_phrase(code : Int) -> String {
  if code == 200 {
    "OK"
  } else if code == 201 {
    "Created"
  } else if code == 202 {
    "Accepted"
  } else if code == 204 {
    "No Content"
  } else if code == 400 {
    "Bad Request"
  } else if code == 401 {
    "Unauthorized"
  } else if code == 403 {
    "Forbidden"
  } else if code == 404 {
    "Not Found"
  } else if code == 405 {
    "Method Not Allowed"
  } else if code == 409 {
    "Conflict"
  } else if code == 500 {
    "Internal Server Error"
  } else {
    "OK"
  }
}

///|
fn server_meth_ctor(http_method : String) -> String raise {
  match http_method.to_upper() {
    "GET" => "@http.Get"
    "HEAD" => "@http.Head"
    "POST" => "@http.Post"
    "PUT" => "@http.Put"
    "DELETE" => "@http.Delete"
    "PATCH" => "@http.Patch"
    "OPTIONS" => "@http.Options"
    "TRACE" => "@http.Trace"
    "CONNECT" => "@http.Connect"
    _ => fail("unsupported http method: \{http_method}")
  }
}

///|
fn normalize_uri_template(template : String) -> String {
  let p1 = template.split("{?").to_array()
  let s = if p1.length() == 0 { template } else { p1[0].to_string() }
  let p2 = s.split("?").to_array()
  if p2.length() == 0 {
    s
  } else {
    p2[0].to_string()
  }
}

///|
fn compact_alpha_digit_underscore(s : String) -> String {
  let n = s.length()
  let sb = StringBuilder::new(size_hint=n)
  let mut i = 0
  while i < n {
    let ch = s.code_unit_at(i)
    if ch == '_' && i > 0 && i + 1 < n {
      let prev = s.code_unit_at(i - 1)
      let next = s.code_unit_at(i + 1)
      let prev_is_lower = prev >= 'a' && prev <= 'z'
      let next_is_digit = next >= '0' && next <= '9'
      if prev_is_lower && next_is_digit {
        i += 1
        continue
      }
    }
    sb.write_char(ch.to_int().unsafe_to_char())
    i += 1
  }
  sb.to_string()
}

///|
fn pick_handler_var(used : Array[String], base : String) -> String {
  let mut candidate = base
  let mut suffix = 1
  while true {
    let mut exists = false
    for name in used {
      if name == candidate {
        exists = true
        break
      }
    }
    if !exists {
      break
    }
    candidate = "\{base}_\{suffix}"
    suffix += 1
  }
  candidate
}

///|
fn emit_server_router(crate : @codemodel.Crate) -> String raise {
  let buf = StringBuilder::new(size_hint=8192)

  // 1) SSE typed streams/writers
  let sse_unions = collect_sse_unions(crate)
  let sse_union_list = sse_unions.to_array()
  sse_union_list.sort_by_key(fn(u) { u.0 })
  for item in sse_union_list {
    write_sse_event_stream(buf, item.1)
  }

  // 2) SSE operation result enums
  for client in crate.clients {
    for op in client.methods {
      if !op.is_sse {
        continue
      }
      match op.sse_event_union {
        Some(u) => write_sse_result_enum(buf, client, op, u)
        None =>
          fail("sse operation \{client.name}.\{op.name} missing events union")
      }
    }
  }

  // 3) Handler Traits
  for client in crate.clients {
    let trait_name = @case.pascal_case(client.name) + "Handler"
    buf.write_string(
      (
        $|///|
        $|/// Traits for operation handlers
        $|pub(open) trait \{trait_name} {
      ),
    )
    buf.write_char('\n')
    for op in client.methods {
      let return_type = match op.response_body {
        Some(t) => type_ref_to_string(t)
        None => "Unit"
      }
      buf.write_string("  async ")
      buf.write_string(@case.snake_case(op.name))
      buf.write_string("(Self, group~ : @async.TaskGroup[Unit]")
      for p in op.parameters {
        buf.write_string(", ")
        buf.write_string(@case.snake_case(p.name))
        buf.write_string(" : ")
        buf.write_string(type_ref_to_string(p.type_))
      }
      buf.write_string(") -> ")
      if op.is_sse {
        wln(buf, sse_result_name(client, op))
      } else {
        wln(buf, return_type)
      }
    }
    buf.write_string(
      (
        #|  
        #|}
      ),
    )
    buf.write_char('\n')
  }

  // 4) RouteMatch + create_router + create_dispatch
  buf.write_string(
    (
      #|///|
      #|/// 路由匹配结果。
      #|#warnings("-unused_constructor")
      #|pub enum RouteMatch {
      #|  /// 已命中并写入响应（或已开始 SSE）。
      #|  Handled
      #|  /// 路径完全不匹配。
      #|  NotMatched
      #|  /// 路径匹配但 method 不被支持（可用于返回 405）。
      #|  MethodNotAllowed
      #|}
      #|
      #|///|
      #|pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch
      #|
    ),
  )
  wln(buf, "")

  // 2.1) match_route (可基准测试的纯匹配逻辑)
  buf.write_string(
    (
      #|///|
      #|/// 生成期固定的路由 ID（用于 match_route 的返回值）。
      #|#warnings("-unused_constructor")
      #|pub enum RouteId {
    ),
  )
  buf.write_char('\n')
  for client in crate.clients {
    let client_prefix = @case.pascal_case(
      @codegen.sanitize_identifier(client.name),
    )
    for op in client.methods {
      let op_part = @case.pascal_case(@codegen.sanitize_identifier(op.name))
      let ctor = client_prefix + op_part
      let path_params = op.parameters.filter(fn(p) { p.location == "path" })
      if path_params.length() == 0 {
        wln(buf, "  \{ctor}")
      } else {
        buf.write_string("  \{ctor}(")
        let mut first = true
        for p in path_params {
          if !first {
            buf.write_string(", ")
          }
          first = false
          // enum payload 可以使用 label 参数：`name~ : Type`，调用侧用 `name=...` 传参。
          let pname = @codegen.sanitize_identifier(@case.snake_case(p.name))
          buf.write_string("\{pname}~ : String")
        }
        wln(buf, ")")
      }
    }
  }
  wln(buf, "}")
  wln(buf, "")
  buf.write_string(
    (
      #|///|
      #|/// 路由匹配结果（纯匹配：不读 body、不写响应、不调用 handler）。
      #|#warnings("-unused_constructor")
      #|pub enum MatchRouteResult {
      #|  NotMatched
      #|  MethodNotAllowed
      #|  Matched(RouteId)
      #|}
      #|
      #|///|
      #|/// 匹配 method + path，并返回命中的 RouteId（若命中）。
      #|///
      #|/// 约定：
      #|/// - `NotMatched`：path 不匹配任何 route
      #|/// - `MethodNotAllowed`：path 匹配但 method 不支持
      #|/// - `Matched`：method+path 匹配（并包含必要的 path 参数）
      #|pub fn match_route(meth : @http.RequestMethod, full_path : String) -> MatchRouteResult {
    ),
  )
  buf.write_char('\n')
  // 生成期构建 prefix string trie（radix trie），运行时使用 StringView 进行前缀匹配与 slice。
  let routes : Array[RouteSpec] = Array::new()
  for client in crate.clients {
    let client_prefix = @case.pascal_case(
      @codegen.sanitize_identifier(client.name),
    )
    for op in client.methods {
      let meth_ctor = server_meth_ctor(op.http_method)
      let normalized_tmpl = normalize_uri_template(op.path)
      let segments = parse_route_segments(normalized_tmpl)

      // 校验：template 里出现的 `{param}` 与 operation.path 参数集合一致（名字必须相同）。
      let tmpl_param_names : Array[String] = Array::new()
      for seg in segments {
        match seg {
          Param(name) => tmpl_param_names.push(name)
          _ => ()
        }
      }
      let tmpl_param_set : Map[String, Unit] = Map::new()
      for name in tmpl_param_names {
        if tmpl_param_set.contains(name) {
          fail("duplicate path parameter name in template: \{normalized_tmpl}")
        }
        tmpl_param_set.set(name, ())
      }
      let op_param_names : Array[String] = Array::new()
      let path_param_vars : Array[String] = Array::new()
      let op_param_set : Map[String, Unit] = Map::new()
      for p in op.parameters {
        if p.location == "path" {
          op_param_names.push(p.name)
          path_param_vars.push(sanitize_path_param_var(p.name))
          if op_param_set.contains(p.name) {
            fail(
              "duplicate path parameter name in operation parameters: \{normalized_tmpl}",
            )
          }
          op_param_set.set(p.name, ())
        }
      }
      // op.parameters(path) ⊆ template
      let tmpl_list = join_strings(tmpl_param_names, ", ")
      let op_list = join_strings(op_param_names, ", ")
      for name in op_param_names {
        if !tmpl_param_set.contains(name) {
          fail(
            "path parameters mismatch between template and operation parameters: \{normalized_tmpl} (template=[\{tmpl_list}], op=[\{op_list}])",
          )
        }
      }
      let op_part = @case.pascal_case(@codegen.sanitize_identifier(op.name))
      let route_id_ctor = client_prefix + op_part
      routes.push(RouteSpec::{
        segments,
        meth_ctor,
        route_id_ctor,
        path_param_vars,
      })
    }
  }
  let route_tree = into_route_tree(routes)
  wln(buf, "  let path = @runtime.strip_request_query(full_path)")
  emit_match_route_handler(buf, 1, route_tree)
  wln(buf, "}")
  wln(buf, "")
  buf.write_string("pub fn[")
  for i in 0..<crate.clients.length() {
    let client = crate.clients[i]
    let trait_name = @case.pascal_case(
        @codegen.sanitize_identifier(client.name),
      ) +
      "Handler"
    buf.write_string("H\{i.to_string()} : \{trait_name}, ")
  }
  buf.write_string("] create_router(\n")
  let used_handler_vars : Array[String] = Array::new()
  let client_handler_vars : Array[String] = Array::new()
  for i in 0..<crate.clients.length() {
    let client = crate.clients[i]
    let base = {
      let s = compact_alpha_digit_underscore(
        @codegen.sanitize_identifier(@case.snake_case(client.name)),
      )
      if s == "" {
        "h\{i.to_string()}"
      } else {
        "\{s}_handler"
      }
    }
    let handler_var = pick_handler_var(used_handler_vars, base)
    used_handler_vars.push(handler_var)
    client_handler_vars.push(handler_var)
    buf.write_string(
      (
        $|  \{handler_var}~ : H\{i.to_string()},
        $|
      ),
    )
  }
  buf.write_string(
    (
      #|  group~ : @async.TaskGroup[Unit],
      #|) -> Router {
      #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) -> RouteMatch {
      #|    let full_path = req.path
      #|    match match_route(req.meth, full_path) {
      #|      MatchRouteResult::Matched(route_id) => {
      #|        match route_id {
      #|
    ),
  )
  let mut op_counter = 0
  for ci in 0..<crate.clients.length() {
    let client = crate.clients[ci]
    let handler_var = client_handler_vars[ci]
    let client_prefix = @case.pascal_case(
      @codegen.sanitize_identifier(client.name),
    )
    for op in client.methods {
      op_counter += 1
      let op_part = @case.pascal_case(@codegen.sanitize_identifier(op.name))
      let ctor = client_prefix + op_part
      let path_params = op.parameters.filter(fn(p) { p.location == "path" })
      if path_params.length() == 0 {
        wln(buf, "          RouteId::\{ctor} => {")
      } else {
        buf.write_string("          RouteId::\{ctor}(")
        for i in 0..<path_params.length() {
          if i > 0 {
            buf.write_string(", ")
          }
          let pname = @codegen.sanitize_identifier(
            @case.snake_case(path_params[i].name),
          )
          buf.write_string("\{pname}~")
        }
        wln(buf, ") => {")
      }

      // detect body presence
      let has_body = for param in op.parameters {
        if param.location == "body" {
          break true
        }
      } else {
        false
      }
      if has_body {
        buf.write_string(
          (
            #|            let body_bytes = body_stream.read_all()
            #|            let body_str = body_bytes.text()
            #|
          ),
        )
      } else {
        wln(buf, "            ignore(body_stream)")
      }
      wln(buf, "            ")
      let call_arg_exprs : Array[String] = Array::new()
      for param in op.parameters {
        let pname = @codegen.sanitize_identifier(@case.snake_case(param.name))
        match param.location {
          "path" => call_arg_exprs.push(pname)
          _ => {
            let var_name = "p_\{op_counter.to_string()}_\{pname}"
            call_arg_exprs.push(var_name)
            match param.location {
              "body" =>
                wln(
                  buf,
                  "            let \{var_name} : \{type_ref_to_string(param.type_)} = @json.from_json(@json.parse(body_str))",
                )
              "header" =>
                wln(
                  buf,
                  "            let \{var_name} = @runtime.get_header(req.headers, \"\{param.name}\")",
                )
              "query" =>
                wln(
                  buf,
                  "            let \{var_name} = @runtime.get_query_param(full_path, \"\{param.name}\")",
                )
              _ => fail("unsupported parameter location: \{param.location}")
            }
          }
        }
      }
      if op.is_sse {
        let result_enum = sse_result_name(client, op)
        let sse_union = match op.sse_event_union {
          Some(u) => u
          None =>
            fail("sse operation \{client.name}.\{op.name} missing events union")
        }
        buf.write_string(
          "            let sse_result = \{handler_var}.\{@case.snake_case(op.name)}(group~, ",
        )
        for arg in call_arg_exprs {
          buf.write_string("\{arg},")
        }
        wln(buf, ")")
        buf.write_string(
          (
            $|            match sse_result {
            $|              \{result_enum}::Stream(stream) => {
            $|                let sse = @runtime.EventStreamWriter::start(conn, \{op.status_code.to_string()}, "\{status_reason_phrase(op.status_code)}")
            $|                for {
            $|                  match stream.next() {
            $|                    Some(event) => match event {
            $|
          ),
        )
        for v in sse_union.variants {
          let ctor = @case.pascal_case(@codegen.sanitize_identifier(v.name))
          let data_type = type_ref_to_string(v.type_)
          let data_expr = if data_type == "String" {
            "payload"
          } else {
            "payload.to_json().stringify()"
          }
          let event_name = StringBuilder::new()
          write_escaped_string_literal(event_name, v.name)
          wln(
            buf,
            "                      \{ctor}(payload) => sse.write_event(event?=Some(\"\{event_name.to_string()}\"), data=\{data_expr})",
          )
        }
        buf.write_string(
          (
            #|                    }
            #|                    None => break
            #|                  }
            #|                }
            #|                sse.close()
            #|              }
            #|
          ),
        )
        for err in op.sse_error_responses {
          let ctor = status_variant_name(err.status_code)
          match err.body {
            Some(_) =>
              buf.write_string(
                (
                  $|              \{result_enum}::\{ctor}(resp_body) => {
                  $|                let headers : Map[String, String] = { "content-type": "application/json" }
                  $|                conn.send_response(\{err.status_code.to_string()}, "\{status_reason_phrase(err.status_code)}", extra_headers=headers)
                  $|                conn.write(resp_body.to_json().stringify())
                  $|                conn.end_response()
                  $|              }
                  $|
                ),
              )
            None =>
              buf.write_string(
                (
                  $|              \{result_enum}::\{ctor} => {
                  $|                conn.send_response(\{err.status_code.to_string()}, "\{status_reason_phrase(err.status_code)}")
                  $|                conn.end_response()
                  $|              }
                  $|
                ),
              )
          }
        }
        buf.write_string(
          (
            #|            }
            #|            RouteMatch::Handled
            #|          }
            #|
          ),
        )
        continue
      }
      let has_response_body = op.response_body is Some(_)
      if has_response_body {
        buf.write_string(
          "            let resp_body = \{handler_var}.\{@case.snake_case(op.name)}(group~, ",
        )
        for arg in call_arg_exprs {
          buf.write_string("\{arg},")
        }
        buf.write_string(
          (
            $|)
            $|            let headers : Map[String, String] = { "content-type": "application/json" }
            $|            conn.send_response(\{op.status_code.to_string()}, "\{status_reason_phrase(op.status_code)}", extra_headers=headers)
            $|            conn.write(resp_body.to_json().stringify())
            $|            conn.end_response()
            $|            RouteMatch::Handled
            $|          }
            $|
          ),
        )
      } else {
        buf.write_string(
          "            \{handler_var}.\{@case.snake_case(op.name)}(group~, ",
        )
        for arg in call_arg_exprs {
          buf.write_string("\{arg},")
        }
        buf.write_string(
          (
            $|)
            $|            conn.send_response(\{op.status_code.to_string()}, "\{status_reason_phrase(op.status_code)}")
            $|            conn.end_response()
            $|            RouteMatch::Handled
            $|          }
            $|
          ),
        )
      }
    }
  }
  buf.write_string(
    (
      #|        }
      #|      }
      #|      MatchRouteResult::MethodNotAllowed => RouteMatch::MethodNotAllowed
      #|      MatchRouteResult::NotMatched => RouteMatch::NotMatched
      #|    }
      #|  }
      #|}
      #|
    ),
  )
  wln(buf, "")
  buf.write_string(
    (
      #|///|
      #|/// 创建一个“带默认 fallback”的 dispatch（`async (...)->Unit`），便于直接挂到 http server。
      #|///
      #|/// - `Handled`：router 已写入响应
      #|/// - `MethodNotAllowed`：发送 405
      #|/// - `NotMatched`：发送 404
      #|pub fn create_dispatch(router : Router) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit {
      #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) {
      #|    let result = router(req, body_stream, conn)
      #|    match result {
      #|      RouteMatch::Handled => ()
      #|      RouteMatch::MethodNotAllowed => {
      #|        conn.send_response(405, "Method Not Allowed")
      #|        conn.end_response()
      #|      }
      #|      RouteMatch::NotMatched => {
      #|        conn.send_response(404, "Not Found")
      #|        conn.write("not found")
      #|        conn.end_response()
      #|      }
      #|    }
      #|  }
      #|}
      #|
    ),
  )
  buf.to_string()
}
