/// Server 代码生成实现（放在 server emitter package 内，避免 codegen 包承担 server 生成逻辑）。

///|
fn type_ref_to_string(type_ : @codemodel.TypeRef) -> String {
  match type_ {
    String => "String"
    Int32 => "Int"
    Int64 => "Int64"
    Float64 => "Double"
    Bool => "Bool"
    Json => "Json"
    Model(m) => @case.pascal_case(m.name)
    Union(u) => @case.pascal_case(u.name)
    Array(t) => "Array[\{type_ref_to_string(t)}]"
    Record(t) => "Map[String, \{type_ref_to_string(t)}]"
    Nullable(t) => "Nullable[\{type_ref_to_string(t)}]"
  }
}

///|
fn wln(sb : StringBuilder, s : String) -> Unit {
  sb.write_string(s)
  sb.write_char('\n')
}

///|
fn write_escaped_string_literal(sb : StringBuilder, s : String) -> Unit {
  // Escape `\` and `"` for MoonBit string literal.
  let n = s.length()
  let mut i = 0
  while i < n {
    let ch = s.code_unit_at(i)
    if ch == '\\' {
      sb.write_string("\\\\")
    } else if ch == '"' {
      sb.write_string("\\\"")
    } else {
      sb.write_char(ch.to_int().unsafe_to_char())
    }
    i += 1
  }
}

///|
pub fn emit_server_files(
  crate : @codemodel.Crate,
) -> Array[@codegen.OutputFile] raise {
  [
    @codegen.OutputFile::new("moon.pkg.json", emit_server_moon_pkg_json()),
    @codegen.OutputFile::new("README.mbt.md", emit_server_readme(crate)),
    @codegen.OutputFile::new("models.mbt", emit_server_models(crate)),
    @codegen.OutputFile::new("router.mbt", emit_server_router(crate)),
  ]
}

///|
fn emit_server_moon_pkg_json() -> String {
  (
    #|{
    #|  "import": [
    #|    "moonbitlang/async",
    #|    "moonbitlang/async/http",
    #|    "moonbitlang/async/io",
    #|    "kkkiio/typespec-moonbit-server-runtime/runtime",
    #|    "moonbitlang/core/json"
    #|  ]
    #|}
  )
}

///|
fn emit_server_readme(crate : @codemodel.Crate) -> String {
  (
    $|# \{crate.name}
    $|
    $|Generated by typespec-moonbit.
    $|
    $|This MoonBit package can be imported by other packages to start a server.
  )
}

///|
fn write_union(sb : StringBuilder, u : @codemodel.Union) -> Unit raise {
  let enum_name = @case.pascal_case(u.name)
  wln(sb, "///|")
  wln(sb, "/// Union \{u.name}")
  wln(sb, "pub(all) enum \{enum_name} {")
  let n = u.variants.length()
  guard n > 0 else { fail("union \{u.name} has no variants") }
  for i in 0..<n {
    let v = u.variants[i]
    let ctor = @case.pascal_case(@codegen.sanitize_identifier(v.name))
    wln(sb, "  \{ctor}(\{type_ref_to_string(v.type_)})")
  }
  wln(sb, "} derive(Show)")
  wln(sb, "")
  wln(sb, "///|")
  wln(sb, "pub impl Default for \{enum_name} with default() {")
  let default_variant = u.variants[0]
  let default_ctor = @case.pascal_case(
    @codegen.sanitize_identifier(default_variant.name),
  )
  wln(
    sb,
    "  \{default_ctor}(\{type_ref_to_string(default_variant.type_)}::default())",
  )
  wln(sb, "}")
  wln(sb, "")
  wln(sb, "///|")
  wln(
    sb,
    "pub impl ToJson for \{enum_name} with to_json(self : \{enum_name}) -> Json {",
  )
  wln(sb, "  match self {")
  for i in 0..<n {
    let v = u.variants[i]
    let ctor = @case.pascal_case(@codegen.sanitize_identifier(v.name))
    wln(sb, "    \{ctor}(v) => v.to_json()")
  }
  wln(sb, "  }")
  wln(sb, "}")
  wln(sb, "")
}

///|
fn write_model(
  sb : StringBuilder,
  m : @codemodel.Model,
  derive_fromjson : Bool,
) -> Unit raise {
  wln(sb, "///|")
  wln(sb, "/// Model \{m.name}")
  let struct_name = @case.pascal_case(m.name)
  wln(sb, "pub(all) struct \{struct_name} {")

  // NOTE: 不考虑 @encodedName；wire name 直接用 TypeSpec property.name。
  // 为避免歧义，若两个字段映射到同一个 snake_case 标识符，直接报错。
  let seen_field_names : Map[String, String] = Map::new() // field_name -> wire_name
  let rename_entries : Array[(String, String)] = Array::new()
  for f in m.fields {
    let field_name = @codegen.sanitize_identifier(@case.snake_case(f.name))
    if seen_field_names.contains(field_name) {
      let prev = seen_field_names.get(field_name).unwrap()
      if prev != f.name {
        fail(
          "model field name collision after snake_case: \{m.name}.\{prev} and \{m.name}.\{f.name} both map to \{field_name}",
        )
      }
    } else {
      seen_field_names.set(field_name, f.name)
    }
    let mut line = "  \{field_name} : \{type_ref_to_string(f.type_)}"
    if f.optional {
      line = line + "?"
    }
    wln(sb, line)
    if field_name != f.name {
      rename_entries.push((field_name, f.name))
    }
  }
  sb.write_string("} derive(Show, ")
  let has_renames = rename_entries.length() > 0
  if !has_renames {
    sb.write_string("ToJson")
  } else {
    sb.write_string("ToJson(fields(")
    let n = rename_entries.length()
    for i in 0..<n {
      let entry = rename_entries[i]
      sb.write_string("\{entry.0}(rename=\"\{entry.1}\")")
      if i != n - 1 {
        sb.write_string(", ")
      }
    }
    sb.write_string("))")
  }
  if derive_fromjson {
    sb.write_string(", ")
    if !has_renames {
      sb.write_string("@json.FromJson")
    } else {
      sb.write_string("@json.FromJson(fields(")
      let n = rename_entries.length()
      for i in 0..<n {
        let entry = rename_entries[i]
        sb.write_string("\{entry.0}(rename=\"\{entry.1}\")")
        if i != n - 1 {
          sb.write_string(", ")
        }
      }
      sb.write_string("))")
    }
  }
  wln(sb, ")")
  wln(sb, "")
}

///|
fn collect_decode_models_from_crate(
  crate : @codemodel.Crate,
) -> Map[String, @codemodel.Model] raise {
  let models = Map::new()
  fn collect_decode_models(type_ : @codemodel.TypeRef) -> Unit raise {
    match type_ {
      Union(u) =>
        fail(
          "Not supported: request-side untagged union \{u.name} in server code generation",
        )
      Model(m) =>
        if !models.contains(m.name) {
          models.set(m.name, m)
          for field in m.fields {
            collect_decode_models(field.type_)
          }
        }
      Array(t) => collect_decode_models(t)
      Record(t) => collect_decode_models(t)
      Nullable(t) => collect_decode_models(t)
      _ => ()
    }
  }

  for client in crate.clients {
    for op in client.methods {
      for param in op.parameters {
        collect_decode_models(param.type_)
      }
    }
  }
  models
}

///|
fn collect_encode_types_from_crate(
  crate : @codemodel.Crate,
) -> (Map[String, @codemodel.Model], Map[String, @codemodel.Union]) {
  let models = Map::new()
  let unions = Map::new()
  for client in crate.clients {
    for op in client.methods {
      match op.response_body {
        Some(t) => collect_encode_types(t, models, unions)
        None => ()
      }
    }
  }
  (models, unions)
}

///|
fn collect_encode_types(
  type_ : @codemodel.TypeRef,
  models : Map[String, @codemodel.Model],
  unions : Map[String, @codemodel.Union],
) -> Unit {
  match type_ {
    Model(m) =>
      if !models.contains(m.name) {
        models.set(m.name, m)
        for field in m.fields {
          collect_encode_types(field.type_, models, unions)
        }
      }
    Union(u) =>
      if !unions.contains(u.name) {
        unions.set(u.name, u)
        for v in u.variants {
          collect_encode_types(v.type_, models, unions)
        }
      }
    Array(t) => collect_encode_types(t, models, unions)
    Record(t) => collect_encode_types(t, models, unions)
    Nullable(t) => collect_encode_types(t, models, unions)
    _ => ()
  }
}

///|
fn emit_server_models(crate : @codemodel.Crate) -> String raise {
  let buf = StringBuilder::new(size_hint=8192)

  // Nullable helper (for `T | null`) is provided by runtime.
  buf.write_string(
    "///|\n#warnings(\"-unused_type_declaration\")\npub using @runtime {type Nullable}\n\n",
  )
  let decode_models = collect_decode_models_from_crate(crate)
  let (encode_models, encode_unions) = collect_encode_types_from_crate(crate)
  let models = encode_models.merge(decode_models)

  // Union Enums (ToJson only)
  let union_list = encode_unions.to_array()
  union_list.sort_by_key(fn(u) { u.0 })
  for item in union_list {
    write_union(buf, item.1)
  }

  // Model Structs
  let model_list = models.to_array()
  model_list.sort_by_key(fn(m) { m.0 })
  for item in model_list {
    let m = item.1
    write_model(buf, m, decode_models.contains(m.name))
  }
  buf.to_string()
}

///|
fn status_reason_phrase(code : Int) -> String {
  if code == 200 {
    "OK"
  } else if code == 201 {
    "Created"
  } else if code == 202 {
    "Accepted"
  } else if code == 204 {
    "No Content"
  } else if code == 400 {
    "Bad Request"
  } else if code == 401 {
    "Unauthorized"
  } else if code == 403 {
    "Forbidden"
  } else if code == 404 {
    "Not Found"
  } else if code == 405 {
    "Method Not Allowed"
  } else if code == 409 {
    "Conflict"
  } else if code == 500 {
    "Internal Server Error"
  } else {
    "OK"
  }
}

///|
fn server_meth_ctor(http_method : String) -> String raise {
  match http_method.to_upper() {
    "GET" => "@http.Get"
    "HEAD" => "@http.Head"
    "POST" => "@http.Post"
    "PUT" => "@http.Put"
    "DELETE" => "@http.Delete"
    "PATCH" => "@http.Patch"
    "OPTIONS" => "@http.Options"
    "TRACE" => "@http.Trace"
    "CONNECT" => "@http.Connect"
    _ => fail("unsupported http method: \{http_method}")
  }
}

///|
fn normalize_uri_template(template : String) -> String {
  let p1 = template.split("{?").to_array()
  let s = if p1.length() == 0 { template } else { p1[0].to_string() }
  let p2 = s.split("?").to_array()
  if p2.length() == 0 {
    s
  } else {
    p2[0].to_string()
  }
}

///|
fn compact_alpha_digit_underscore(s : String) -> String {
  let n = s.length()
  let sb = StringBuilder::new(size_hint=n)
  let mut i = 0
  while i < n {
    let ch = s.code_unit_at(i)
    if ch == '_' && i > 0 && i + 1 < n {
      let prev = s.code_unit_at(i - 1)
      let next = s.code_unit_at(i + 1)
      let prev_is_lower = prev >= 'a' && prev <= 'z'
      let next_is_digit = next >= '0' && next <= '9'
      if prev_is_lower && next_is_digit {
        i += 1
        continue
      }
    }
    sb.write_char(ch.to_int().unsafe_to_char())
    i += 1
  }
  sb.to_string()
}

///|
fn pick_handler_var(used : Array[String], base : String) -> String {
  let mut candidate = base
  let mut suffix = 1
  while true {
    let mut exists = false
    for name in used {
      if name == candidate {
        exists = true
        break
      }
    }
    if !exists {
      break
    }
    candidate = "\{base}_\{suffix}"
    suffix += 1
  }
  candidate
}

///|
fn emit_server_router(crate : @codemodel.Crate) -> String raise {
  let buf = StringBuilder::new(size_hint=8192)

  // 1) Handler Traits
  for client in crate.clients {
    wln(buf, "///|")
    wln(buf, "/// Traits for operation handlers")
    let trait_name = @case.pascal_case(client.name) + "Handler"
    wln(buf, "pub(open) trait \{trait_name} {")
    for op in client.methods {
      let return_type = match op.response_body {
        Some(t) => type_ref_to_string(t)
        None => "Unit"
      }
      buf.write_string("  async ")
      buf.write_string(@case.snake_case(op.name))
      buf.write_string("(Self, group~ : @async.TaskGroup[Unit]")
      for p in op.parameters {
        buf.write_string(", ")
        buf.write_string(@case.snake_case(p.name))
        buf.write_string(" : ")
        buf.write_string(type_ref_to_string(p.type_))
      }
      if op.is_sse {
        buf.write_string(", sse : @runtime.EventStreamWriter")
      }
      buf.write_string(") -> ")
      if op.is_sse {
        wln(buf, "Unit")
      } else {
        wln(buf, return_type)
      }
    }
    wln(buf, "  ")
    wln(buf, "}")
  }

  // 2) RouteMatch + create_router + create_dispatch
  wln(buf, "///|")
  wln(buf, "/// 路由匹配结果。")
  wln(buf, "#warnings(\"-unused_constructor\")")
  wln(buf, "pub enum RouteMatch {")
  wln(buf, "  /// 已命中并写入响应（或已开始 SSE）。")
  wln(buf, "  Handled")
  wln(buf, "  /// 路径完全不匹配。")
  wln(buf, "  NotMatched")
  wln(
    buf, "  /// 路径匹配但 method 不被支持（可用于返回 405）。",
  )
  wln(buf, "  MethodNotAllowed")
  wln(buf, "}")
  wln(buf, "")
  wln(buf, "///|")
  wln(
    buf, "pub type Router = async (@http.Request, &@io.Reader, @http.ServerConnection) -> RouteMatch",
  )
  wln(buf, "")
  buf.write_string("pub fn[")
  for i in 0..<crate.clients.length() {
    let client = crate.clients[i]
    let trait_name = @case.pascal_case(
        @codegen.sanitize_identifier(client.name),
      ) +
      "Handler"
    buf.write_string("H\{i.to_string()} : \{trait_name}, ")
  }
  buf.write_string("] create_router(\n")
  let used_handler_vars : Array[String] = Array::new()
  let client_handler_vars : Array[String] = Array::new()
  for i in 0..<crate.clients.length() {
    let client = crate.clients[i]
    let base = {
      let s = compact_alpha_digit_underscore(
        @codegen.sanitize_identifier(@case.snake_case(client.name)),
      )
      if s == "" {
        "h\{i.to_string()}"
      } else {
        "\{s}_handler"
      }
    }
    let handler_var = pick_handler_var(used_handler_vars, base)
    used_handler_vars.push(handler_var)
    client_handler_vars.push(handler_var)
    wln(buf, "  \{handler_var}~ : H\{i.to_string()},")
    wln(buf, "  ")
  }
  wln(buf, "  group~ : @async.TaskGroup[Unit],")
  wln(buf, ") -> Router {")
  wln(
    buf, "  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) -> RouteMatch {",
  )
  wln(buf, "    let full_path = req.path")
  wln(buf, "    let path = @runtime.strip_request_query(full_path)")
  wln(buf, "    ")
  let mut op_counter = 0
  for ci in 0..<crate.clients.length() {
    let client = crate.clients[ci]
    let handler_var = client_handler_vars[ci]
    for op in client.methods {
      op_counter += 1
      let meth = server_meth_ctor(op.http_method)
      let normalized_tmpl = normalize_uri_template(op.path)
      buf.write_string(
        "    if req.meth == \{meth} && @runtime.match_path_template(\"",
      )
      write_escaped_string_literal(buf, normalized_tmpl)
      wln(buf, "\", path) {")

      // detect body presence
      let has_body = for param in op.parameters {
        if param.location == "body" {
          break true
        }
      } else {
        false
      }
      if has_body {
        wln(buf, "      let body_bytes = body_stream.read_all()")
        wln(buf, "      let body_str = body_bytes.text()")
      } else {
        wln(buf, "      ignore(body_stream)")
      }
      wln(buf, "      ")
      let call_arg_exprs : Array[String] = Array::new()
      for param in op.parameters {
        let pname = @codegen.sanitize_identifier(@case.snake_case(param.name))
        let var_name = "p_\{op_counter.to_string()}_\{pname}"
        call_arg_exprs.push(var_name)
        match param.location {
          "body" =>
            wln(
              buf,
              "      let \{var_name} : \{type_ref_to_string(param.type_)} = @json.from_json(@json.parse(body_str))",
            )
          "path" => {
            buf.write_string(
              "      let \{var_name} = @runtime.get_path_param(\"",
            )
            write_escaped_string_literal(buf, normalized_tmpl)
            buf.write_string("\", path, \"\{param.name}\")\n")
          }
          "header" =>
            wln(
              buf,
              "      let \{var_name} = @runtime.get_header(req.headers, \"\{param.name}\")",
            )
          "query" =>
            wln(
              buf,
              "      let \{var_name} = @runtime.get_query_param(full_path, \"\{param.name}\")",
            )
          _ => fail("unsupported parameter location: \{param.location}")
        }
      }
      if op.is_sse {
        wln(
          buf,
          "      let sse = @runtime.EventStreamWriter::start(conn, \{op.status_code.to_string()}, \"\{status_reason_phrase(op.status_code)}\")",
        )
        call_arg_exprs.push("sse")
        buf.write_string(
          "      \{handler_var}.\{@case.snake_case(op.name)}(group~, ",
        )
        for arg in call_arg_exprs {
          buf.write_string("\{arg},")
        }
        wln(buf, ")")
        wln(buf, "      return RouteMatch::Handled")
        wln(buf, "    }")
        wln(buf, "    ")
        continue
      }
      let has_response_body = op.response_body is Some(_)
      if has_response_body {
        buf.write_string(
          "      let resp_body = \{handler_var}.\{@case.snake_case(op.name)}(group~, ",
        )
        for arg in call_arg_exprs {
          buf.write_string("\{arg},")
        }
        wln(buf, ")")
        wln(
          buf, "      let headers : Map[String, String] = { \"content-type\": \"application/json\" }",
        )
        wln(
          buf,
          "      conn.send_response(\{op.status_code.to_string()}, \"\{status_reason_phrase(op.status_code)}\", extra_headers=headers)",
        )
        wln(buf, "      conn.write(resp_body.to_json().stringify())")
        wln(buf, "      conn.end_response()")
        wln(buf, "      return RouteMatch::Handled")
        wln(buf, "    }")
        wln(buf, "    ")
      } else {
        buf.write_string(
          "      \{handler_var}.\{@case.snake_case(op.name)}(group~, ",
        )
        for arg in call_arg_exprs {
          buf.write_string("\{arg},")
        }
        wln(buf, ")")
        wln(
          buf,
          "      conn.send_response(\{op.status_code.to_string()}, \"\{status_reason_phrase(op.status_code)}\")",
        )
        wln(buf, "      conn.end_response()")
        wln(buf, "      return RouteMatch::Handled")
        wln(buf, "    }")
        wln(buf, "    ")
      }
    }
  }
  wln(
    buf, "    // 未找到“method+path 完全匹配”的 handler。再判定是否是“path 匹配但 method 不支持”。",
  )
  wln(buf, "    let mut path_matched = false")
  for client in crate.clients {
    for op in client.methods {
      buf.write_string("    if @runtime.match_path_template(\"")
      write_escaped_string_literal(buf, normalize_uri_template(op.path))
      buf.write_string("\", path) { path_matched = true }\n")
    }
  }
  wln(
    buf, "    if path_matched { RouteMatch::MethodNotAllowed } else { RouteMatch::NotMatched }",
  )
  wln(buf, "  }")
  wln(buf, "}")
  wln(buf, "")
  buf.write_string(
    (
      #|///|
      #|/// 创建一个“带默认 fallback”的 dispatch（`async (...)->Unit`），便于直接挂到 http server。
      #|///
      #|/// - `Handled`：router 已写入响应
      #|/// - `MethodNotAllowed`：发送 405
      #|/// - `NotMatched`：发送 404
      #|pub fn create_dispatch(router : Router) -> async (@http.Request, &@io.Reader, @http.ServerConnection) -> Unit {
      #|  async fn(req : @http.Request, body_stream : &@io.Reader, conn : @http.ServerConnection) {
      #|    let result = router(req, body_stream, conn)
      #|    match result {
      #|      RouteMatch::Handled => ()
      #|      RouteMatch::MethodNotAllowed => {
      #|        conn.send_response(405, "Method Not Allowed")
      #|        conn.end_response()
      #|      }
      #|      RouteMatch::NotMatched => {
      #|        conn.send_response(404, "Not Found")
      #|        conn.write("not found")
      #|        conn.end_response()
      #|      }
      #|    }
      #|  }
      #|}
      #|
    ),
  )
  buf.to_string()
}
